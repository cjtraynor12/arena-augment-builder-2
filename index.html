<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Augment Builder</title>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        .save-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-left: 5px;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s;
            vertical-align: middle;
        }
        
        .save-icon:hover {
            opacity: 1;
        }
        
        .save-icon.saved {
            opacity: 1;
            filter: hue-rotate(120deg);
        }
        
        .form-row-with-save {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .slider-with-save {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 1000;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        
        .toast.error {
            background: #dc3545;
        }
        
        /* Split Drop Zone Styles */
        .icon-drop-zone {
            top: 0;
            height: 50%;
            border-color: #007bff;
            background-color: rgba(0, 123, 255, 0.1);
        }
        
        .frame-drop-zone {
            top: 50%;
            height: 50%;
            border-color: #28a745;
            background-color: rgba(40, 167, 69, 0.1);
        }
        
        .icon-drop-zone .drop-text {
            color: #007bff;
        }
        
        .frame-drop-zone .drop-text {
            color: #28a745;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Augments Section -->
        <div class="augments-section">
            <!-- Arena Augments Content -->
            <div id="arenaAugmentsContent">
                <div class="search-container">
                    <input type="text" id="arenaAugmentSearchInput" class="search-input" placeholder="Search arena augments..." oninput="updateArenaAugmentSearch(this.value)">
                    <span class="clear-button" onclick="updateArenaAugmentSearch(''); document.getElementById('arenaAugmentSearchInput').value = '';">‚úñ</span>
                    <!-- Tab Navigation -->
                    <div class="tab-navigation">
                        <button id="arenaAugmentsTabBtn1" class="tab-btn active" onclick="switchAugmentTab('arena')">Arena</button>
                        <button id="aramAugmentsTabBtn1" class="tab-btn" onclick="switchAugmentTab('aram')">ARAM</button>
                    </div>
                </div>
                <div class="list" id="arenaAugmentsList"></div>
            </div>
            
            <!-- ARAM Augments Content -->
            <div id="aramAugmentsContent" style="display: none;">
                <div class="search-container">
                    <input type="text" id="aramAugmentSearchInput" class="search-input" placeholder="Search ARAM augments..." oninput="updateAramAugmentSearch(this.value)">
                    <span class="clear-button" onclick="updateAramAugmentSearch(''); document.getElementById('aramAugmentSearchInput').value = '';">‚úñ</span>
                    <!-- Tab Navigation -->
                    <div class="tab-navigation">
                        <button id="arenaAugmentsTabBtn2" class="tab-btn" onclick="switchAugmentTab('arena')">Arena</button>
                        <button id="aramAugmentsTabBtn2" class="tab-btn active" onclick="switchAugmentTab('aram')">ARAM</button>
                    </div>
                </div>
                <div class="list" id="aramAugmentsList"></div>
            </div>
        </div>

        <!-- Controls Section -->
        <div class="controls-section">
            <div class="image-controls">
                <div class="image-container">
                    <div id="canvasContainer">
                        <img id="imageOutput" alt="Generated augment image">
                        <div id="iconDropZone" class="drop-overlay icon-drop-zone">
                            <div class="drop-text">Drop image to replace icon</div>
                        </div>
                        <div id="frameDropZone" class="drop-overlay frame-drop-zone">
                            <div class="drop-text">Drop image to replace frame</div>
                        </div>
                    </div>
                    <div class="vertical-slider-container">
                        <div class="vertical-slider-group">
                            <div class="vertical-slider-label">Icon Y</div>
                            <input type="range" min="0" max="600" value="40" class="vertical-slider" id="iconYOffset" oninput="updateCanvasVariable(parseInt(this.value), 'iconYOffset')" orient="vertical">
                        </div>
                        <div class="vertical-slider-group">
                            <div class="vertical-slider-label">Title Y</div>
                            <input type="range" min="0" max="600" value="324" class="vertical-slider" id="titleYOffset" oninput="updateCanvasVariable(parseInt(this.value), 'titleYOffset')" orient="vertical">
                        </div>
                        <div class="vertical-slider-group">
                            <div class="vertical-slider-label">Desc Y</div>
                            <input type="range" min="0" max="600" value="364" class="vertical-slider" id="descriptionYOffset" oninput="updateCanvasVariable(parseInt(this.value), 'descriptionYOffset')" orient="vertical">
                        </div>
                        <div class="vertical-controls-row">
                            <div class="form-row">
                                <label for="customFrame">Frame Override</label>
                                <div style="display: flex; gap: 5px; align-items: center;">
                                    <select id="customFrame" oninput="updateFrameVariable(this.value)" style="flex: 1;">
                                        <option value="augmentcard_bg">No Frame</option>
                                        <option value="augmentcard_frame_silver">Silver</option>
                                        <option value="augmentcard_frame_gold">Gold</option>
                                        <option value="augmentcard_frame_prismatic">Prismatic</option>
                                        <option value="augmentcard_sheenglow_silver">Shiny Silver</option>
                                        <option value="augmentcard_sheenglow_gold">Shiny Gold</option>
                                        <option value="augmentcard_sheenglow_prismatic">Shiny Prismatic</option>
                                    </select>
                                    <button onclick="clearCustomFrame()" title="Clear custom frame" style="background-color: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">üóëÔ∏è</button>
                                </div>
                            </div>

                            <div class="form-row">
                                <label for="itemModifierSelect">Item Modifier</label>
                                <select id="itemModifierSelect" oninput="updateModifierVariable(this.value)">
                                    <option value="0">None</option>
                                </select>
                            </div>

                            <div class="form-row">
                                <label for="languageSelect">Language</label>
                                <select id="languageSelect" oninput="setLanguage(this.value)">
                                    <option value="ar_ae">ar_ae</option>
                                    <option value="cs_cz">cs_cz</option>
                                    <option value="de_de">de_de</option>
                                    <option value="el_gr">el_gr</option>
                                    <option value="en_au">en_au</option>
                                    <option value="en_gb">en_gb</option>
                                    <option value="en_ph">en_ph</option>
                                    <option value="en_sg">en_sg</option>
                                    <option value="en_us" selected>en_us</option>
                                    <option value="es_ar">es_ar</option>
                                    <option value="es_es">es_es</option>
                                    <option value="es_mx">es_mx</option>
                                    <option value="fr_fr">fr_fr</option>
                                    <option value="hu_hu">hu_hu</option>
                                    <option value="it_it">it_it</option>
                                    <option value="ja_jp">ja_jp</option>
                                    <option value="ko_kr">ko_kr</option>
                                    <option value="pl_pl">pl_pl</option>
                                    <option value="pt_br">pt_br</option>
                                    <option value="ro_ro">ro_ro</option>
                                    <option value="ru_ru">ru_ru</option>
                                    <option value="th_th">th_th</option>
                                    <option value="tr_tr">tr_tr</option>
                                    <option value="vi_vn">vi_vn</option>
                                    <option value="zh_cn">zh_cn</option>
                                    <option value="zh_my">zh_my</option>
                                    <option value="zh_tw">zh_tw</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="form-controls">
                <div class="form-controls-left">
                    <div class="form-row">
                        <label for="titleInput">Title</label>
                        <textarea name="titleInput" id="titleInput" placeholder="Enter title..." oninput="updateCanvasVariable(this.value, 'augmentTitle')"></textarea>
                    </div>

                    <div class="form-row">
                        <label for="titleFontInput">Title Font</label>
                        <input name="titleFontInput" id="titleFontInput" placeholder="e.g., bold 24px LolBeautfortBold" oninput="updateCanvasVariable(this.value, 'titleFont')"/>
                    </div>

                    <div class="form-row">
                        <label for="descriptionInput">Description</label>
                        <textarea name="descriptionInput" id="descriptionInput" placeholder="Enter description..." oninput="updateCanvasVariable(this.value, 'augmentDescription')"></textarea>
                    </div>

                    <div class="form-row">
                        <label for="descriptionFontInput">Description Font</label>
                        <input name="descriptionFontInput" id="descriptionFontInput" placeholder="e.g., 14px LolBeautfort" oninput="updateCanvasVariable(this.value, 'descriptionFont')"/>
                    </div>

                    <div class="form-row">
                        <label for="presetSelect">Presets</label>
                        <div style="display: flex; gap: 5px; align-items: center;">
                            <select id="presetSelect" onchange="selectPreset(this.value)" style="flex: 1;">
                                <option value="Default">Default</option>
                            </select>
                            <button onclick="saveNewPreset()" title="Save as new preset" style="background-color: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">üíæ</button>
                            <button onclick="updateCurrentPreset()" title="Update current preset" style="background-color: #007bff; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">üìù</button>
                            <button onclick="deleteCurrentPreset()" title="Delete current preset" style="background-color: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">üóëÔ∏è</button>
                        </div>
                    </div>

                </div>

                <div class="form-controls-right">
                    <!-- Screen Navigation -->
                    <div class="screen-navigation" style="display: flex; gap: 5px; margin-bottom: 10px;">
                        <button onclick="switchScreen('main')" id="mainScreenBtn" class="screen-btn active" style="flex: 1; padding: 4px 8px; border: 1px solid #ccc; background: #007bff; color: white; border-radius: 4px; cursor: pointer; font-size: 12px;">Main</button>
                        <button onclick="switchScreen('advanced')" id="advancedScreenBtn" class="screen-btn" style="flex: 1; padding: 4px 8px; border: 1px solid #ccc; background: #f8f9fa; color: #333; border-radius: 4px; cursor: pointer; font-size: 12px;">Advanced</button>
                        <button onclick="switchScreen('colors')" id="colorsScreenBtn" class="screen-btn" style="flex: 1; padding: 4px 8px; border: 1px solid #ccc; background: #f8f9fa; color: #333; border-radius: 4px; cursor: pointer; font-size: 12px;">Colors</button>
                        <button onclick="switchScreen('icons')" id="iconsScreenBtn" class="screen-btn" style="flex: 1; padding: 4px 8px; border: 1px solid #ccc; background: #f8f9fa; color: #333; border-radius: 4px; cursor: pointer; font-size: 12px;">Icons</button>
                    </div>

                    <!-- Main Screen -->
                    <div id="mainScreen" class="settings-screen">
                        <div class="sliderForm">
                            <label for="iconXOffset">Icon X Offset</label>
                            <input type="range" min="0" max="512" value="156" class="slider" id="iconXOffset" oninput="updateCanvasVariable(parseInt(this.value), 'iconXOffset')">
                            <output name="iconXOutput" for="iconXOffset">156</output>
                        </div>

                        <div class="sliderForm">
                            <label for="iconSize">Icon Size</label>
                            <input type="range" min="50" max="300" value="150" class="slider" id="iconSize" oninput="updateCanvasVariable(parseInt(this.value), 'iconSize')">
                            <output name="iconSizeOutput" for="iconSize">150</output>
                        </div>

                        <div class="sliderForm">
                            <label for="titleLineHeight">Title Line Height</label>
                            <input type="range" min="0" max="64" value="26" class="slider" id="titleLineHeight" oninput="updateCanvasVariable(parseInt(this.value), 'titleLineHeight')">
                            <output name="titleLineHeightOutput" for="titleLineHeight">26</output>
                        </div>

                        <div class="sliderForm">
                            <label for="descriptionLineHeight">Description Line Height</label>
                            <input type="range" min="0" max="64" value="18" class="slider" id="descriptionLineHeight" oninput="updateCanvasVariable(parseInt(this.value), 'descriptionLineHeight')">
                            <output name="descriptionLineHeightOutput" for="descriptionLineHeight">18</output>
                        </div>
                    </div>

                    <!-- Advanced Screen -->
                    <div id="advancedScreen" class="settings-screen" style="display: none;">
                        <div class="form-row">
                            <label for="letterSpacing">Letter Spacing</label>
                            <input type="number" id="letterSpacing" step="0.1" value="0.5" oninput="updateCanvasVariable(parseFloat(this.value), 'letterSpacing')" style="width: 100%; padding: 4px; border: 1px solid #ccc; border-radius: 4px;">
                        </div>

                        <div class="form-row">
                            <label for="titleMaxWidth">Title Max Width</label>
                            <input type="number" id="titleMaxWidth" value="220" oninput="updateCanvasVariable(parseInt(this.value), 'titleMaxWidth')" style="width: 100%; padding: 4px; border: 1px solid #ccc; border-radius: 4px;">
                        </div>

                        <div class="form-row">
                            <label for="descriptionMaxWidth">Description Max Width</label>
                            <input type="number" id="descriptionMaxWidth" value="220" oninput="updateCanvasVariable(parseInt(this.value), 'descriptionMaxWidth')" style="width: 100%; padding: 4px; border: 1px solid #ccc; border-radius: 4px;">
                        </div>
                    </div>

                    <!-- Colors Screen -->
                    <div id="colorsScreen" class="settings-screen" style="display: none;">
                        <div style="margin-bottom: 10px;">
                            <button onclick="addColorRow()" style="background-color: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 5px;">+ Add Color</button>
                            <button onclick="saveColorTable()" style="background-color: #007bff; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; margin-right: 5px;">üíæ Save</button>
                            <button onclick="resetColorTable()" style="background-color: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">üîÑ Reset</button>
                        </div>
                        <div id="colorTableEditor" style="max-height: 200px; overflow-y: auto; border: 1px solid #ccc; padding: 5px; border-radius: 4px;">
                            <!-- Color rows will be populated here -->
                        </div>
                    </div>

                    <!-- Icons Screen -->
                    <div id="iconsScreen" class="settings-screen" style="display: none;">
                        <div style="margin-bottom: 10px; text-align: center; color: #ccc; font-size: 12px;">
                            Click an icon to insert it at your cursor position in the description
                        </div>
                        <div id="iconGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); gap: 4px; max-height: 200px; overflow-y: auto; border: 1px solid #555; padding: 8px; border-radius: 4px; background: #2a2a2a;">
                            <!-- Icon buttons will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Icons Section (Champions/Items) -->
        <div class="champions-section">
            <!-- Champions Content -->
            <div id="championsContent">
                <div class="search-container">
                    <input type="text" id="championSearchInput" class="search-input" placeholder="Search champions..." oninput="updateChampionSearch(this.value)">
                    <span class="clear-button" onclick="updateChampionSearch(''); document.getElementById('championSearchInput').value = '';">‚úñ</span>
                    <!-- Tab Navigation -->
                    <div class="tab-navigation">
                        <button id="championsTabBtn" class="tab-btn active" onclick="switchIconTab('champions')">Champions</button>
                        <button id="arenaItemsTabBtn" class="tab-btn" onclick="switchIconTab('arenaItems')">Arena Items</button>
                        <button id="itemsTabBtn" class="tab-btn" onclick="switchIconTab('items')">Items</button>
                    </div>
                </div>
                <div class="list" id="championsList"></div>
            </div>
            
            <!-- Arena Items Content -->
            <div id="arenaItemsContent" style="display: none;">
                <div class="search-container">
                    <input type="text" id="arenaItemSearchInput" class="search-input" placeholder="Search arena items..." oninput="updateArenaItemSearch(this.value)">
                    <span class="clear-button" onclick="updateArenaItemSearch(''); document.getElementById('arenaItemSearchInput').value = '';">‚úñ</span>
                    <!-- Tab Navigation -->
                    <div class="tab-navigation">
                        <button id="championsTabBtn" class="tab-btn" onclick="switchIconTab('champions')">Champions</button>
                        <button id="arenaItemsTabBtn" class="tab-btn active" onclick="switchIconTab('arenaItems')">Arena Items</button>
                        <button id="itemsTabBtn" class="tab-btn" onclick="switchIconTab('items')">Items</button>
                    </div>
                </div>
                <div class="list" id="arenaItemsList"></div>
            </div>
            
            <!-- Items Content -->
            <div id="itemsContent" style="display: none;">
                <div class="search-container">
                    <input type="text" id="itemSearchInput" class="search-input" placeholder="Search items..." oninput="updateItemSearch(this.value)">
                    <span class="clear-button" onclick="updateItemSearch(''); document.getElementById('itemSearchInput').value = '';">‚úñ</span>
                    <!-- Tab Navigation -->
                    <div class="tab-navigation">
                        <button id="championsTabBtn" class="tab-btn" onclick="switchIconTab('champions')">Champions</button>
                        <button id="arenaItemsTabBtn" class="tab-btn" onclick="switchIconTab('arenaItems')">Arena Items</button>
                        <button id="itemsTabBtn" class="tab-btn active" onclick="switchIconTab('items')">Items</button>
                    </div>
                </div>
                <div class="list" id="itemsList"></div>
            </div>
        </div>
    </div>

    <script>
        // ===== CALCULATION ENGINE =====
        class CalculationEngine {
            constructor() {
                // Static mappings for known placeholders
                this.staticMappings = {
                    '{{ Item_Keyword_OnHit }}': 'On-Hit'
                };
                
                // Common spell property mappings for better descriptions
                this.spellPropertyMappings = {
                    'MSAmount': 'Move Speed',
                    'MovementSpeed': 'Move Speed', 
                    'BuffDuration': 'duration',
                    'DisableCooldown': 'disable duration',
                    'DamageAmp': 'damage amplification',
                    'Gold': 'gold'
                };
                
                // Common calculation type descriptions
                this.calculationDescriptions = {
                    // Level-based scaling patterns
                    'level_scaling': (startValue, endValue) => `${startValue}-${endValue} (scales with level)`,
                    
                    // Stat scaling patterns
                    'stat_scaling': (coefficient, statType) => {
                        const statNames = {
                            2: 'AD', // Attack Damage
                            5: 'AP', // Ability Power
                            6: 'Health',
                            7: 'Mana',
                            8: 'Armor',
                            9: 'Magic Resist',
                            10: 'Attack Speed',
                            11: 'Move Speed'
                        };
                        
                        const statName = statNames[statType] || 'stat';
                        const percentage = Math.round(coefficient * 100);
                        return `${percentage}% ${statName}`;
                    },
                    
                    // Conditional calculations
                    'conditional': (condition, trueValue, falseValue) => {
                        if (condition === 'IsRangedCastRequirement') {
                            return `${trueValue} (ranged) / ${falseValue} (melee)`;
                        }
                        return `varies by condition`;
                    },
                    
                    // Percentage display
                    'percentage': (value) => `${Math.round(value * 100)}%`,
                    
                    // Flat value with context
                    'flat_value': (value, context = '') => `${value}${context}`
                };
            }

            processCalculations(description, augment) {
                let processedDescription = description;
                
                // Handle static mappings first
                for (const [placeholder, replacement] of Object.entries(this.staticMappings)) {
                    processedDescription = processedDescription.replaceAll(placeholder, replacement);
                }
                
                // Handle @calculation@ placeholders
                processedDescription = this.processCalculationPlaceholders(processedDescription, augment);
                
                // Handle @spell.SpellName:Property@ placeholders
                processedDescription = this.processSpellPlaceholders(processedDescription, augment);
                
                // Handle {{ Cherry_AugmentName_Summary }} placeholders
                processedDescription = this.processSummaryPlaceholders(processedDescription, augment);
                
                return processedDescription;
            }

            processCalculationPlaceholders(description, augment) {
                const calculations = augment.calculations || {};
                
                // Find all @word@ patterns that aren't already handled by dataValues
                // Use strict pattern to only match valid variable names (alphanumeric + underscore)
                const calculationMatches = description.match(/@([A-Za-z0-9_]+)@/g);
                if (!calculationMatches) return description;
                
                let processedDescription = description;
                
                for (const match of calculationMatches) {
                    const calcName = match.slice(1, -1); // Remove @ symbols
                    
                    // Skip if this is a dataValue (already handled elsewhere)
                    if (augment.dataValues && augment.dataValues.hasOwnProperty(calcName)) {
                        continue;
                    }
                    
                    // Look for calculation
                    if (calculations[calcName]) {
                        const calculationResult = this.interpretCalculation(calculations[calcName]);
                        processedDescription = processedDescription.replaceAll(match, calculationResult);
                    } else {
                        // Fallback for unknown calculations
                        processedDescription = processedDescription.replaceAll(match, `[${calcName}]`);
                    }
                }
                
                return processedDescription;
            }

            processSpellPlaceholders(description, augment) {
                const spellMatches = description.match(/@spell\.([^:]+):([^@*]+)(\*[^@]*)?@/g);
                if (!spellMatches) return description;
                
                let processedDescription = description;
                
                for (const match of spellMatches) {
                    // Parse the spell reference
                    const content = match.slice(7, -1); // Remove @spell. and @
                    const parts = content.split(':');
                    const spellName = parts[0];
                    const propertyWithMultiplier = parts[1];
                    
                    // Check for multiplier in the property
                    let property = propertyWithMultiplier;
                    let multiplier = '';
                    if (propertyWithMultiplier.includes('*')) {
                        const multiplierIndex = propertyWithMultiplier.indexOf('*');
                        property = propertyWithMultiplier.substring(0, multiplierIndex);
                        multiplier = propertyWithMultiplier.substring(multiplierIndex);
                    }
                    
                    // Create a more descriptive replacement
                    const propertyDescription = this.spellPropertyMappings[property] || property;
                    let replacement = `[${propertyDescription}]`;
                    
                    // Handle multipliers for better display
                    if (multiplier === '*100') {
                        replacement = `[${propertyDescription}%]`;
                    } else if (multiplier) {
                        replacement = `[${propertyDescription} ${multiplier}]`;
                    }
                    
                    processedDescription = processedDescription.replaceAll(match, replacement);
                }
                
                return processedDescription;
            }

            processSummaryPlaceholders(description, augment) {
                const summaryMatches = description.match(/\{\{\s*([^}]+)\s*\}\}/g);
                if (!summaryMatches) return description;
                
                let processedDescription = description;
                
                for (const match of summaryMatches) {
                    const content = match.slice(2, -2).trim(); // Remove {{ }}
                    
                    // Handle known summary types
                    if (content.includes('Cherry_') && content.includes('_Summary')) {
                        const augmentName = content.replace('Cherry_', '').replace('_Summary', '');
                        processedDescription = processedDescription.replaceAll(match, `[${augmentName} effect]`);
                    } else {
                        // Keep as is for unknown patterns
                        processedDescription = processedDescription.replaceAll(match, `[${content}]`);
                    }
                }
                
                return processedDescription;
            }

            interpretCalculation(calculation) {
                if (!calculation || !calculation.mFormulaParts) {
                    return '[calculation]';
                }
                
                const parts = calculation.mFormulaParts;
                const descriptions = [];
                
                for (const part of parts) {
                    const partType = part.__type;
                    
                    switch (partType) {
                        case 'ByCharLevelInterpolationCalculationPart':
                            const startValue = Math.round(part.mStartValue || 0);
                            const endValue = Math.round(part.mEndValue || 0);
                            descriptions.push(this.calculationDescriptions.level_scaling(startValue, endValue));
                            break;
                            
                        case 'StatByCoefficientCalculationPart':
                            const coefficient = part.mCoefficient || 0;
                            const statType = part.mStat || 0;
                            descriptions.push(this.calculationDescriptions.stat_scaling(coefficient, statType));
                            break;
                            
                        case 'EffectValueCalculationPart':
                            const value = Math.round(part.mEffectValue || 0);
                            descriptions.push(this.calculationDescriptions.flat_value(value));
                            break;
                            
                        case 'GameCalculationConditional':
                            // Handle conditional calculations
                            const condition = part.mConditionalCalculationRequirements?.__type;
                            const trueCalc = this.interpretCalculation(part.mConditionalGameCalculation);
                            const falseCalc = this.interpretCalculation(part.mDefaultGameCalculation);
                            descriptions.push(this.calculationDescriptions.conditional(condition, trueCalc, falseCalc));
                            break;
                            
                        default:
                            descriptions.push('[complex calculation]');
                    }
                }
                
                // Handle display formatting
                if (calculation.mDisplayAsPercent) {
                    return descriptions.map(desc => `${desc}%`).join(' + ');
                }
                
                return descriptions.join(' + ') || '[calculation]';
            }

            processDataValue(varName, multiplier, dataValues) {
                let varValue = dataValues[varName];
                
                if (varValue === undefined) {
                    return `[${varName}]`;
                }
                
                if (multiplier) {
                    // Use safer evaluation than eval
                    if (multiplier === '*100') {
                        varValue = varValue * 100;
                    } else if (multiplier === '*-100') {
                        varValue = varValue * -100;
                    } else {
                        // Try to parse the multiplier as a number
                        const multiplierValue = parseFloat(multiplier.substring(1)); // Remove the '*'
                        if (!isNaN(multiplierValue)) {
                            varValue = varValue * multiplierValue;
                        } else {
                            // Unknown multiplier format - return as-is with placeholder
                            console.warn(`Unknown multiplier format: ${multiplier} for variable ${varName}`);
                            return `[${varName}${multiplier}]`;
                        }
                    }
                }
                
                // Format the value nicely
                varValue = Math.fround(varValue);
                varValue = Math.floor(varValue * 100) / 100;
                
                return varValue.toString();
            }
        }

        // Initialize calculation engine
        const calculationEngine = new CalculationEngine();

        // ===== LOCAL STORAGE MODULE =====
        function saveToLocalStorage(key, value) {
            try {
                localStorage.setItem(`augmentBuilder_${key}`, JSON.stringify(value));
                return true;
            } catch (e) {
                console.error('Failed to save to localStorage:', e);
                return false;
            }
        }

        function loadFromLocalStorage(key, defaultValue) {
            try {
                const stored = localStorage.getItem(`augmentBuilder_${key}`);
                return stored ? JSON.parse(stored) : defaultValue;
            } catch (e) {
                console.error('Failed to load from localStorage:', e);
                return defaultValue;
            }
        }

        function saveSettingWithIcon(settingKey, elementId) {
            const element = document.getElementById(elementId);
            const value = element.type === 'range' ? parseInt(element.value) : element.value;
            
            if (saveToLocalStorage(settingKey, value)) {
                // Update the save icon to show saved state
                const saveIcon = document.querySelector(`[data-save-for="${elementId}"]`);
                if (saveIcon) {
                    saveIcon.classList.add('saved');
                    setTimeout(() => saveIcon.classList.remove('saved'), 2000);
                }
                
                // Update settings and refresh display
                settings[settingKey] = value;
                mergeAugmentImages();
            }
        }

        function createSaveIcon(elementId) {
            const icon = document.createElement('span');
            icon.className = 'save-icon';
            icon.setAttribute('data-save-for', elementId);
            icon.innerHTML = 'üíæ';
            icon.title = 'Save this setting';
            return icon;
        }

        function loadSavedSettings() {
            // Load all saved settings
            const savedSettings = {
                iconXOffset: loadFromLocalStorage('iconXOffset', 156),
                iconYOffset: loadFromLocalStorage('iconYOffset', 40),
                iconSize: loadFromLocalStorage('iconSize', 150),
                titleYOffset: loadFromLocalStorage('titleYOffset', 324),
                descriptionYOffset: loadFromLocalStorage('descriptionYOffset', 364),
                titleLineHeight: loadFromLocalStorage('titleLineHeight', 26),
                descriptionLineHeight: loadFromLocalStorage('descriptionLineHeight', 18),
                titleFont: loadFromLocalStorage('titleFont', 'bold 24px LolBeautfortBold'),
                descriptionFont: loadFromLocalStorage('descriptionFont', '14px LolBeautfort'),
                customFrame: loadFromLocalStorage('customFrame', 'augmentcard_frame_prismatic'),
                language: loadFromLocalStorage('language', 'en_us')
            };

            // Apply saved settings to elements and settings object
            Object.keys(savedSettings).forEach(key => {
                const value = savedSettings[key];
                settings[key] = value;
                
                // Update form elements - handle font inputs specially
                const element = document.getElementById(key === 'titleFont' ? 'titleFontInput' : 
                                                      key === 'descriptionFont' ? 'descriptionFontInput' : key);
                if (element) {
                    element.value = value;
                    
                    // Update output elements for sliders
                    const output = document.querySelector(`output[for="${key}"]`);
                    if (output) {
                        output.value = value;
                    }
                }
            });

            // Special handling for frame selection
            if (savedSettings.customFrame) {
                settings['selectedFrame'] = borderImages[savedSettings.customFrame];
                settings['shinyFrame'] = savedSettings.customFrame.includes("sheenglow");
            }
        }

        function resetAllSettings() {
            if (confirm('Reset all saved settings to defaults? This cannot be undone.')) {
                // Clear all localStorage items
                const keys = ['iconXOffset', 'iconYOffset', 'iconSize', 'titleYOffset', 'descriptionYOffset', 
                             'titleLineHeight', 'descriptionLineHeight', 'titleFont', 'descriptionFont', 
                             'customFrame', 'language'];
                
                keys.forEach(key => {
                    localStorage.removeItem(`augmentBuilder_${key}`);
                });
                
                // Reload the page to reset everything
                location.reload();
            }
        }

        // ===== CANVAS RENDERER MODULE =====
        function createHiPPICanvas(width, height) {
            const ratio = window.devicePixelRatio;
            const canvas = document.createElement("canvas");

            canvas.width = width * ratio;
            canvas.height = height * ratio;
            canvas.style.width = width + "px";
            canvas.style.height = height + "px";
            canvas.getContext("2d").scale(ratio, ratio);

            return canvas;
        }

        // Modified from https://github.com/lukechilds/merge-images/blob/master/src/index.js
        const defaultOptions = {
            format: 'image/png',
            quality: 1,
            width: undefined,
            height: undefined,
            Canvas: undefined,
            crossOrigin: true
        };

        const mergeImages = (sources = [], options = {}, offsets = {}, title = "", description = "", iconSize = 256) => new Promise(resolve => {
            options = Object.assign({}, defaultOptions, options);

            const canvas = options.Canvas ? new options.Canvas() : createHiPPICanvas(600, 600);
            const Image = options.Image || window.Image;

            const images = sources.map(source => new Promise((resolve, reject) => {
                if (source.constructor.name !== 'Object') {
                    source = { src: source };
                }

                const img = new Image();
                img.crossOrigin = options.crossOrigin;
                img.onerror = () => reject(new Error('Couldn\'t load image'));
                img.onload = () => resolve(Object.assign({}, source, { img }));
                img.src = source.src;
            }));

            const ctx = canvas.getContext('2d');

            resolve(Promise.all(images)
                .then(images => {
                    canvas.width = 512;
                    canvas.height = 600;

                    images.forEach((image, index) => {
                        ctx.globalAlpha = image.opacity ? image.opacity : 1;

                        let xOffset = 0;
                        let yOffset = 0;
                        if (offsets[index]) {xOffset = offsets[index][0]; yOffset = offsets[index][1]}

                        yOffset += 44;

                        const xPosition = xOffset > 0 ? xOffset : image.x || 0;
                        const yPosition = yOffset > 0 ? yOffset : image.y || 0;

                        if (index === 2) {
                            // Main icon - use custom size
                            return ctx.drawImage(image.img, xPosition, yPosition, iconSize, iconSize);
                        } else if (index === 3) {
                            // Modifier overlay - scale with icon size
                            return ctx.drawImage(image.img, xPosition, yPosition, iconSize, iconSize);
                        } else {
                            if (index === 1 && settings['shinyFrame']) {
                                return ctx.drawImage(image.img, xPosition - 256, yPosition - 256);
                            } else if (index === 1 && settings['customFrame']) {
                                // For custom frames, we need to center them properly
                                // Check if the image is larger than standard frame size and adjust accordingly
                                const standardWidth = 512;
                                const standardHeight = 512;
                                const imgWidth = image.img.naturalWidth || image.img.width;
                                const imgHeight = image.img.naturalHeight || image.img.height;
                                
                                // Calculate offset to center the custom frame
                                const xOffset = (imgWidth - standardWidth) / 2;
                                const yOffset = (imgHeight - standardHeight) / 2;
                                
                                return ctx.drawImage(image.img, xPosition - xOffset, yPosition - yOffset);
                            } else {
                                return ctx.drawImage(image.img, xPosition, yPosition);
                            }
                        }
                    });

                    if (title) {
                        ctx.font = settings['titleFont'];
                        ctx.fillStyle = "white";
                        const titleMaxWidth = settings['titleMaxWidth'] || 220;
                        return wrapText(ctx, title, 256, settings['titleYOffset'], titleMaxWidth, settings['titleLineHeight'])
                            .then(numberOfTitleLines => {
                                ctx.font = settings['descriptionFont'];
                                const descriptionMaxWidth = settings['descriptionMaxWidth'] || 220;
                                return wrapText(ctx, description, 256, settings['descriptionYOffset'] + ((numberOfTitleLines - 1) * settings["titleLineHeight"]), descriptionMaxWidth, settings['descriptionLineHeight']);
                            })
                            .then(() => {
                                return canvas.toDataURL(options.format, options.quality);
                            });
                    }

                    return canvas.toDataURL(options.format, options.quality);
                }));
        });

        async function wrapText(context, text, x, y, maxWidth, lineHeight = 16) {
            // Preprocess text to convert HTML-style font tags to compact format
            const preprocessedText = preprocessFontTags(text);
            
            const linebreakLines = preprocessedText.split("\n");
            const finalLines = [];
            linebreakLines.forEach((line) => finalLines.push(...getLines(context, line, maxWidth)))

            let inRulesSection = false;
            for (let index = 0; index < finalLines.length; index++) {
                const line = finalLines[index];
                inRulesSection = await writeCharacters(context, line, x, (y + (index * lineHeight)), inRulesSection);
            }
            return finalLines.length;
        }

        function preprocessFontTags(text) {
            // Convert <font color = '#hexcode'> to <fontcolor='#hexcode'> to prevent line splitting
            let processedText = text;
            
            // Handle opening font tags with various spacing patterns
            processedText = processedText.replace(/<font\s+color\s*=\s*['"]([^'"]+)['"]\s*>/gi, '<fontcolor=\'$1\'>');
            
            // Handle closing font tags
            processedText = processedText.replace(/<\/font>/gi, '</fontcolor>');
            
            return processedText;
        }

        function getLines(ctx, text, maxWidth) {
            console.log('getLines input text:', text); // Debug log
            
            let words = text.split(" ");
            let lines = [];
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                let word = words[i];
                
                // Handle image tags specially - they should be treated as having a width
                let wordWidth = 0;
                let currentLineWidth = 0;
                
                // Calculate width for current line (excluding tags but accounting for images)
                const currentLineNoTags = currentLine.replaceAll(/(<([^>]+)>)/gi, "");
                const imgMatches = currentLine.match(/<img[^>]*>/gi) || [];
                const fontSize = parseInt(ctx.font.match(/\d+/));
                const imageSize = Math.max(12, fontSize - 2);
                currentLineWidth = ctx.measureText(currentLineNoTags).width + (imgMatches.length * imageSize);
                
                // Calculate width for the word being added
                const wordNoTags = word.replaceAll(/(<([^>]+)>)/gi, "");
                const wordImgMatches = word.match(/<img[^>]*>/gi) || [];
                wordWidth = ctx.measureText(wordNoTags).width + (wordImgMatches.length * imageSize);

                let totalWidth = currentLineWidth + ctx.measureText(" ").width + wordWidth;
                
                if (totalWidth < maxWidth) {
                    currentLine += " " + word;
                } else {
                    console.log('Line break - pushing line:', currentLine); // Debug log
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            console.log('Final line:', currentLine); // Debug log
            lines.push(currentLine);
            
            console.log('getLines output lines:', lines); // Debug log
            return lines;
        }

        const colorTable = {
            // Damage types
            magicDamage: "#30bdd0",
            physicalDamage: "#FF8C00",
            trueDamage: "#FFFFFF",
            
            // Scaling types
            scaleBonus: "#c9aa71",
            scaleHealth: "#60b087",
            scaleAD: "#FF8C00",
            scaleAP: "#00B0F0", 
            scaleMana: "#0099CC",
            scaleArmor: "#C89B3C",
            scaleMR: "#9966CC",
            scaleLethality: "#FF6B6B",
            scaleLevel: "#CDBE91",
            scaleAF: "#c9aa71", // Adaptive Force
            
            // Effects and utilities
            healing: "#60b087",
            shield: '#70b3b4',
            status: '#b29cc0',
            keywordMajor: '#F0E6D2',
            keywordStealth: '#4B0082',
            
            // Speed and combat stats
            speed: '#00FF7F',
            attackSpeed: '#FF6347',
            crit: '#FFD700',
            lifeSteal: '#DC143C',
            energy: '#4169E1',
            
            // UI elements
            spellName: '#dad2b5',
            abilityName: '#dad2b5',
            recast: "rgb(255,143,97)",
            rules: "rgb(255, 255, 255, 0.4)",
            
            // Resistances (fallback colors)
            armor: "#C89B3C",
            magicresistance: "#9966CC"
        }

        // Image cache for inline images
        const imageCache = new Map();

        // Preload all stat icons for better performance
        function preloadStatIcons() {
            console.log('Preloading stat icons...');
            let loadedCount = 0;
            const totalIcons = Object.keys(imageKeywordMap).length;
            
            Object.entries(imageKeywordMap).forEach(([keyword, filename]) => {
                const url = getStatIconUrl(keyword);
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    imageCache.set(url, img);
                    loadedCount++;
                    if (loadedCount === totalIcons) {
                        console.log(`All ${totalIcons} stat icons preloaded successfully`);
                    }
                };
                img.onerror = () => {
                    console.warn(`Failed to preload stat icon: ${keyword} (${url})`);
                    loadedCount++;
                };
                img.src = url;
            });
        }

        function writeCharacters(ctx, str, x, y, inRulesSection) {
            return new Promise((resolve) => {
                const strNoTags = str.replaceAll(/(<([^>]+)>)/gi, "");
                
                // Letter spacing adjustment - use dynamic value from settings
                const letterSpacing = settings['letterSpacing'] || 0.5;
                
                // Manual centering adjustment - adjust these to fine-tune centering with letter spacing
                const titleCenterAdjustment = 2; // Adjust this for title centering (try -5, -10, +5, +10, etc.)
                const descriptionCenterAdjustment = 2; // Adjust this for description centering
                
                // Calculate the total width including letter spacing and images
                let totalWidth = ctx.measureText(strNoTags).width + (strNoTags.length - 1) * letterSpacing;
                
                // Add width for inline images
                const imgMatches = str.match(/<img[^>]*>/gi) || [];
                const fontSize = parseInt(ctx.font.match(/\d+/));
                const imageSize = Math.max(12, fontSize - 2); // Scale images to font size
                totalWidth += imgMatches.length * (imageSize + letterSpacing);
                
                let xCenterAdjustment = totalWidth / 2;
                
                // Apply manual adjustments based on font size (rough detection)
                if (fontSize > 20) {
                    // This is likely a title
                    xCenterAdjustment += titleCenterAdjustment;
                } else {
                    // This is likely description text
                    xCenterAdjustment += descriptionCenterAdjustment;
                }

                let currentX = x - xCenterAdjustment;
                let pendingImages = [];

                for(let i = 0; i <= str.length; ++i) {
                    let ch = str.charAt(i);

                    if (ch === "<") {
                        const endOfTag = str.indexOf(">", i);
                        if (endOfTag !== -1) {
                            const tagContent = str.substring(i + 1, endOfTag);
                            
                            console.log('Processing tag:', tagContent); // Debug log
                            
                            // Handle custom inline image tags - check for imgKeyword format
                            if (tagContent.toLowerCase().startsWith('img')) {
                                const keyword = tagContent.substring(3); // Remove 'img' prefix
                                const imageUrl = getStatIconUrl(keyword);
                                
                                if (imageKeywordMap[keyword]) {
                                    const imageSize = Math.max(12, fontSize - 2);
                                    
                                    console.log('Processing custom image tag:', tagContent, 'keyword:', keyword, 'url:', imageUrl); // Debug log
                                    
                                    // Check cache first
                                    if (imageCache.has(imageUrl)) {
                                        const cachedImg = imageCache.get(imageUrl);
                                        if (cachedImg.complete) {
                                            // Draw cached image
                                            const imageY = y - imageSize + 2; // Align with text baseline
                                            ctx.drawImage(cachedImg, currentX, imageY, imageSize, imageSize);
                                            currentX += imageSize + letterSpacing;
                                            console.log('Drew cached image at', currentX, imageY); // Debug log
                                        }
                                    } else {
                                        // Load new image
                                        const img = new Image();
                                        img.crossOrigin = 'anonymous';
                                        img.onload = () => {
                                            imageCache.set(imageUrl, img);
                                            console.log('Image loaded, redrawing canvas'); // Debug log
                                            // Redraw the entire canvas when image loads
                                            setTimeout(() => {
                                                mergeAugmentImages();
                                            }, 10);
                                        };
                                        img.onerror = () => {
                                            console.warn('Failed to load inline image:', imageUrl);
                                        };
                                        img.src = imageUrl;
                                        
                                        // Reserve space for the image
                                        currentX += imageSize + letterSpacing;
                                        console.log('Reserved space for loading image'); // Debug log
                                    }
                                } else {
                                    console.warn('Unknown image keyword:', keyword); // Debug log
                                }
                                
                                i = endOfTag; // Move past the closing >
                                continue;
                            }
                            // Check for compact font color format: <fontcolor='#hexcode'>
                            else if (tagContent.toLowerCase().startsWith('fontcolor=')) {
                                // Extract hex color from fontcolor attribute
                                const colorMatch = tagContent.match(/fontcolor\s*=\s*['"]([^'"]+)['"]/i);
                                if (colorMatch && colorMatch[1]) {
                                    ctx.fillStyle = colorMatch[1];
                                }
                            }
                            // Check for closing fontcolor tag
                            else if (tagContent.toLowerCase() === '/fontcolor') {
                                // Reset to default color
                                if (inRulesSection) {
                                    ctx.fillStyle = colorTable["rules"];
                                } else {
                                    ctx.fillStyle = "white";
                                }
                            }
                            // Check for HTML-style font color format: <font color = '#hexcode'> (fallback for non-preprocessed text)
                            else if (tagContent.toLowerCase().startsWith('font color')) {
                                // Extract hex color from font color attribute
                                const colorMatch = tagContent.match(/color\s*=\s*['"]([^'"]+)['"]/i);
                                if (colorMatch && colorMatch[1]) {
                                    ctx.fillStyle = colorMatch[1];
                                }
                            }
                            // Check for closing font tag (fallback)
                            else if (tagContent.toLowerCase() === '/font') {
                                // Reset to default color
                                if (inRulesSection) {
                                    ctx.fillStyle = colorTable["rules"];
                                } else {
                                    ctx.fillStyle = "white";
                                }
                            }
                            // Handle existing color name format: <colorName>
                            else {
                                const colorValue = colorTable[tagContent];
                                if (colorValue) {
                                    ctx.fillStyle = colorValue;
                                    if (tagContent === "rules") {
                                        ctx.font = "italic";
                                        inRulesSection = true;
                                    }
                                } else {
                                    if (inRulesSection) {
                                        ctx.fillStyle = colorTable["rules"];
                                        ctx.font = "italic";
                                    } else {
                                        ctx.fillStyle = "white";
                                        inRulesSection = false;
                                    }
                                }
                            }
                            
                            i += endOfTag - i;
                            continue;
                        }
                    }

                    if (ch && ch !== '') {
                        ctx.fillText(ch, currentX, y);
                        currentX += Math.round(ctx.measureText(ch).width) + letterSpacing;
                    }
                }
                
                resolve(inRulesSection);
            });
        }

        // ===== DATA MANAGER MODULE =====
        const arenaJsonDataUrl = "https://raw.communitydragon.org/pbe/cdragon/arena/";
        const championJsonDataUrl = "https://raw.communitydragon.org/latest/plugins/rcp-be-lol-game-data/global/default/v1/champion-summary.json";
        const communityDragonBaseUrl = "https://raw.communitydragon.org/pbe/game/";
        const baseSquarePortraitPath = "https://raw.communitydragon.org/latest/plugins/rcp-be-lol-game-data/global/default/v1/champion-icons/";

        let arenaJsonData = null;
        let championJsonData = null;

        function compareNames(a, b) {
            if (a.name < b.name) return -1;
            if (a.name > b.name) return 1;
            return 0;
        }

        async function getAugmentData(language = 'en_us') {
            const response = await fetch(arenaJsonDataUrl + language + '.json');
            arenaJsonData = (await response.json())['augments'].sort(compareNames);
            return arenaJsonData;
        }

        function getChampionIcon(champion, type) {
            return communityDragonBaseUrl + "assets/characters/" + champion + "/hud/" + champion + "_" + type + ".png";
        }

        async function getChampionData() {
            const response = await fetch(championJsonDataUrl);
            championJsonData = await response.json();

            championJsonData = championJsonData.filter((champion) => champion.id !== -1).sort(compareNames);
            championJsonData = championJsonData.map((champion) => {
                champion['circleIcon'] = getChampionIcon(champion['alias'].toLowerCase(), "circle");
                champion['squareIcon'] = getChampionIcon(champion['alias'].toLowerCase(), "square");
                return champion;
            });

            return championJsonData;
        }

        // Base URL for stat icons to avoid repetition
        const STAT_ICONS_BASE_URL = 'https://raw.communitydragon.org/latest/plugins/rcp-be-lol-game-data/global/default/assets/ux/fonts/texticons/lol/statsicon/';

        // Image keyword mapping for inline images - complete list of available stat icons
        const imageKeywordMap = {
            'onhit': 'onhit.png',
            'scaleAD': 'scalead.png',
            'scaleAdaptiveForce': 'scaleadaptiveforce.png',
            'scaleAH': 'scaleah.png',
            'scaleAP': 'scaleap.png',
            'scaleAPen': 'scaleapen.png',
            'scaleArmor': 'scalearmor.png',
            'scaleAS': 'scaleas.png',
            'scaleCooldown': 'scalecooldown.png',
            'scaleCrit': 'scalecrit.png',
            'scaleCritMult': 'scalecritmult.png',
            'scaleDA': 'scaleda.png',
            'scaleDR': 'scaledr.png',
            'scaleHealShield': 'scalehealshield.png',
            'scaleHealth': 'scalehealth.png',
            'scaleHPRegen': 'scalehpregen.png',
            'scaleLevel': 'scalelevel.png',
            'scaleLS': 'scalels.png',
            'scaleMana': 'scalemana.png',
            'scaleManaRegen': 'scalemanaregen.png',
            'scaleMPen': 'scalempen.png',
            'scaleMR': 'scalemr.png',
            'scaleMS': 'scalems.png',
            'scaleRange': 'scalerange.png',
            'scaleSV': 'scalesv.png',
            'scaleTenacity': 'scaletenacity.png'
        };

        // Helper function to get full URL for a stat icon
        function getStatIconUrl(keyword) {
            return STAT_ICONS_BASE_URL + imageKeywordMap[keyword];
        }

        function populateDescriptionVariables(augment) {
            let description = augment['desc'];
            const dataValues = augment['dataValues'] || {};

            console.log('Original description:', description); // Debug log

            // FIRST: Handle %i:keyword% patterns for inline images BEFORE other processing
            description = description.replaceAll(/%i:([^%]+)%/gi, (match, keyword) => {
                console.log('Converting image pattern:', match, 'keyword:', keyword); // Debug log
                if (imageKeywordMap[keyword]) {
                    const imgTag = `<img${keyword}>`;
                    console.log('Created custom img tag:', imgTag); // Debug log
                    return imgTag;
                }
                console.log('Unknown keyword:', keyword); // Debug log
                return `[${keyword}]`; // Fallback for unknown keywords
            });

            console.log('After image conversion:', description); // Debug log

            // Then handle complex calculations and special placeholders using the calculation engine
            description = calculationEngine.processCalculations(description, augment);

            // Then handle simple @DataValue@ and @DataValue*multiplier@ placeholders
            // Use regex to properly match placeholders: @VariableName@ or @VariableName*multiplier@
            while (description.includes("@")) {
                // Match @VariableName@ or @VariableName*number@ (including negative numbers)
                const match = description.match(/@[A-Za-z0-9_]+(\*-?\d+)?@/);
                
                if (!match) break; // No valid placeholder found, break to avoid infinite loop
                
                const varName = match[0]; // The full matched placeholder like "@HealthReduction*100@"
                let multiplier = null;

                // Extract the variable name and multiplier
                // Remove the @ symbols first
                const innerContent = varName.substring(1, varName.length - 1); // e.g., "HealthReduction*100"
                
                let isolatedVarName;
                if (innerContent.includes("*")) {
                    const asteriskIndex = innerContent.indexOf("*");
                    isolatedVarName = innerContent.substring(0, asteriskIndex); // e.g., "HealthReduction"
                    multiplier = innerContent.substring(asteriskIndex); // e.g., "*100"
                } else {
                    isolatedVarName = innerContent; // e.g., "RoundCountCap"
                }

                // Check if this is a dataValue
                if (dataValues.hasOwnProperty(isolatedVarName)) {
                    const processedValue = calculationEngine.processDataValue(isolatedVarName, multiplier, dataValues);
                    console.log(`Replacing "${varName}" with "${processedValue}"`); // Debug log
                    description = description.replace(varName, processedValue);
                } else {
                    // If not found in dataValues, leave a descriptive placeholder
                    console.log(`Placeholder not found in dataValues: "${varName}"`); // Debug log
                    description = description.replace(varName, `[${isolatedVarName}]`);
                }
            }

            // Clean up the description
            let modifiedDescription = description.replaceAll("<br>", "\n");
            
            // Handle any remaining runtime placeholders (@f1@, @f2@, etc.)
            modifiedDescription = modifiedDescription.replaceAll(/@f(\d+)@/g, '[runtime value]');
            
            console.log('Final processed description:', modifiedDescription); // Debug log
            return modifiedDescription;
        }

        // ===== DRAG AND DROP MODULE =====
        function initializeDragDrop() {
            const canvasContainer = document.getElementById('canvasContainer');
            const iconDropZone = document.getElementById('iconDropZone');
            const frameDropZone = document.getElementById('frameDropZone');

            // Prevent default drag behaviors on container and body
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                canvasContainer.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });

            // Handle drag events for both zones
            ['dragenter', 'dragover'].forEach(eventName => {
                canvasContainer.addEventListener(eventName, handleDragOver, false);
            });

            ['dragleave'].forEach(eventName => {
                canvasContainer.addEventListener(eventName, handleDragLeave, false);
            });

            canvasContainer.addEventListener('drop', handleDrop, false);
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleDragOver(e) {
            const canvasContainer = document.getElementById('canvasContainer');
            const iconDropZone = document.getElementById('iconDropZone');
            const frameDropZone = document.getElementById('frameDropZone');
            
            // Get mouse position relative to canvas container
            const rect = canvasContainer.getBoundingClientRect();
            const y = e.clientY - rect.top;
            const containerHeight = rect.height;
            
            // Determine which zone we're in (top 50% = icon, bottom 50% = frame)
            const isInIconZone = y < containerHeight / 2;
            
            if (isInIconZone) {
                iconDropZone.style.display = 'flex';
                frameDropZone.style.display = 'none';
            } else {
                iconDropZone.style.display = 'none';
                frameDropZone.style.display = 'flex';
            }
        }

        function handleDragLeave(e) {
            // Only hide overlays if we're leaving the canvas container entirely
            const canvasContainer = document.getElementById('canvasContainer');
            const rect = canvasContainer.getBoundingClientRect();
            const x = e.clientX;
            const y = e.clientY;
            
            // Check if mouse is outside the container bounds
            if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                document.getElementById('iconDropZone').style.display = 'none';
                document.getElementById('frameDropZone').style.display = 'none';
            }
        }

        function handleDrop(e) {
            const canvasContainer = document.getElementById('canvasContainer');
            const rect = canvasContainer.getBoundingClientRect();
            const y = e.clientY - rect.top;
            const containerHeight = rect.height;
            
            // Hide both overlays
            document.getElementById('iconDropZone').style.display = 'none';
            document.getElementById('frameDropZone').style.display = 'none';
            
            // Determine which zone the drop occurred in
            const isInIconZone = y < containerHeight / 2;
            
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (isInIconZone) {
                handleFiles(files, 'icon');
            } else {
                handleFiles(files, 'frame');
            }
        }

        function handleFiles(files, dropType) {
            ([...files]).forEach(file => handleFile(file, dropType));
        }

        function handleFile(file, dropType) {
            if (!file.type.startsWith('image/')) {
                alert('Please drop an image file (jpg, png, gif, webp)');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const imageDataUrl = e.target.result;
                if (dropType === 'icon') {
                    setCustomImage(imageDataUrl);
                } else if (dropType === 'frame') {
                    setCustomFrame(imageDataUrl);
                }
            };
            reader.readAsDataURL(file);
        }

        function setCustomImage(imageDataUrl) {
            settings['selectedAugment'] = null;
            settings['selectedChampion'] = null;
            settings['customImage'] = imageDataUrl;
            
            mergeAugmentImages();
        }

        function setCustomFrame(imageDataUrl) {
            settings['customFrame'] = imageDataUrl;
            settings['shinyFrame'] = false; // Custom frames are not shiny
            
            mergeAugmentImages();
        }

        // ===== TOAST NOTIFICATION SYSTEM =====
        function showToast(message, isError = false) {
            // Remove any existing toast
            const existingToast = document.querySelector('.toast');
            if (existingToast) {
                existingToast.remove();
            }
            
            // Create new toast
            const toast = document.createElement('div');
            toast.className = `toast ${isError ? 'error' : ''}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            // Show toast
            setTimeout(() => toast.classList.add('show'), 100);
            
            // Hide and remove toast
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // ===== SCREEN MANAGEMENT =====
        function switchScreen(screenName) {
            // Hide all screens
            document.getElementById('mainScreen').style.display = 'none';
            document.getElementById('advancedScreen').style.display = 'none';
            document.getElementById('colorsScreen').style.display = 'none';
            document.getElementById('iconsScreen').style.display = 'none';
            
            // Show selected screen
            document.getElementById(screenName + 'Screen').style.display = 'block';
            
            // Update button states
            document.querySelectorAll('.screen-btn').forEach(btn => {
                btn.style.background = '#f8f9fa';
                btn.style.color = '#333';
            });
            
            document.getElementById(screenName + 'ScreenBtn').style.background = '#007bff';
            document.getElementById(screenName + 'ScreenBtn').style.color = 'white';
            
            // Initialize color table if switching to colors screen
            if (screenName === 'colors') {
                populateColorTable();
            }
            
            // Initialize icon grid if switching to icons screen
            if (screenName === 'icons') {
                populateIconGrid();
            }
        }

        // ===== ICON GRID MANAGEMENT =====
        function populateIconGrid() {
            const iconGrid = document.getElementById('iconGrid');
            iconGrid.innerHTML = '';
            
            // Create icon buttons for each stat icon
            Object.keys(imageKeywordMap).forEach(keyword => {
                const iconButton = createIconButton(keyword);
                iconGrid.appendChild(iconButton);
            });
        }

        function createIconButton(keyword) {
            const button = document.createElement('button');
            button.style.cssText = `
                width: 36px;
                height: 36px;
                border: 1px solid #555;
                border-radius: 4px;
                background: #3a3a3a;
                cursor: pointer;
                padding: 2px;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s;
            `;
            
            // Add hover effects
            button.onmouseenter = () => {
                button.style.borderColor = '#007bff';
                button.style.backgroundColor = '#4a4a4a';
                button.style.transform = 'scale(1.05)';
            };
            
            button.onmouseleave = () => {
                button.style.borderColor = '#555';
                button.style.backgroundColor = '#3a3a3a';
                button.style.transform = 'scale(1)';
            };
            
            // Use mousedown with preventDefault to avoid losing focus
            button.onmousedown = (e) => {
                e.preventDefault(); // Prevent focus loss from textarea
                insertIconAtCursor(keyword);
            };
            
            // Add tooltip
            button.title = `Insert ${keyword} icon`;
            
            // Create and add the icon image
            const img = document.createElement('img');
            img.src = getStatIconUrl(keyword);
            img.style.cssText = 'width: 28px; height: 28px; pointer-events: none;';
            img.alt = keyword;
            
            button.appendChild(img);
            
            return button;
        }

        function insertIconAtCursor(keyword) {
            const textarea = document.getElementById('descriptionInput');
            const iconTag = `<img${keyword}>`;
            
            // Get current cursor position
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = textarea.value;
            
            // Insert the icon tag at cursor position
            const newText = text.substring(0, start) + iconTag + text.substring(end);
            textarea.value = newText;
            
            // Move cursor to after the inserted text
            const newCursorPos = start + iconTag.length;
            textarea.setSelectionRange(newCursorPos, newCursorPos);
            
            // Keep focus on textarea
            textarea.focus();
            
            // Update the canvas with the new description
            updateCanvasVariable(newText, 'augmentDescription');
        }

        // ===== COLOR TABLE MANAGEMENT =====
        let currentColorTable = { ...colorTable }; // Copy of the original color table

        function loadColorTable() {
            try {
                const stored = localStorage.getItem('augmentBuilder_colorTable');
                if (stored) {
                    currentColorTable = JSON.parse(stored);
                    // Update the global colorTable reference
                    Object.keys(colorTable).forEach(key => delete colorTable[key]);
                    Object.assign(colorTable, currentColorTable);
                }
            } catch (e) {
                console.error('Failed to load color table:', e);
            }
        }

        function saveColorTable() {
            try {
                localStorage.setItem('augmentBuilder_colorTable', JSON.stringify(currentColorTable));
                // Update the global colorTable reference
                Object.keys(colorTable).forEach(key => delete colorTable[key]);
                Object.assign(colorTable, currentColorTable);
                showToast('Color table saved');
                mergeAugmentImages(); // Refresh the canvas
            } catch (e) {
                console.error('Failed to save color table:', e);
                showToast('Failed to save color table', true);
            }
        }

        function resetColorTable() {
            if (confirm('Reset color table to defaults? This cannot be undone.')) {
                // Reset to original color table
                currentColorTable = {
                    // Damage types
                    magicDamage: "#00B0F0",
                    physicalDamage: "#FF8C00",
                    trueDamage: "#FFFFFF",
                    
                    // Scaling types
                    scaleBonus: "#c9aa71",
                    scaleHealth: "#60b087",
                    scaleAD: "#FF8C00",
                    scaleAP: "#00B0F0", 
                    scaleMana: "#0099CC",
                    scaleArmor: "#C89B3C",
                    scaleMR: "#9966CC",
                    scaleLethality: "#FF6B6B",
                    scaleLevel: "#CDBE91",
                    scaleAF: "#c9aa71", // Adaptive Force
                    
                    // Effects and utilities
                    healing: "#60b087",
                    shield: '#70b3b4',
                    status: '#b29cc0',
                    keywordMajor: '#F0E6D2',
                    keywordStealth: '#4B0082',
                    
                    // Speed and combat stats
                    speed: '#00FF7F',
                    attackSpeed: '#FF6347',
                    crit: '#FFD700',
                    lifeSteal: '#DC143C',
                    energy: '#4169E1',
                    
                    // UI elements
                    spellName: '#dad2b5',
                    abilityName: '#dad2b5',
                    recast: "rgb(255,143,97)",
                    rules: "rgb(255, 255, 255, 0.4)",
                    
                    // Resistances (fallback colors)
                    armor: "#C89B3C",
                    magicresistance: "#9966CC"
                };
                
                // Update global reference
                Object.keys(colorTable).forEach(key => delete colorTable[key]);
                Object.assign(colorTable, currentColorTable);
                
                populateColorTable();
                mergeAugmentImages();
                showToast('Color table reset to defaults');
            }
        }

        function populateColorTable() {
            const container = document.getElementById('colorTableEditor');
            container.innerHTML = '';
            
            Object.keys(currentColorTable).forEach(colorName => {
                addColorRowToDOM(colorName, currentColorTable[colorName]);
            });
        }

        function addColorRow() {
            const name = prompt('Enter color name:');
            if (name && name.trim()) {
                const cleanName = name.trim();
                if (currentColorTable.hasOwnProperty(cleanName)) {
                    alert('Color name already exists!');
                    return;
                }
                currentColorTable[cleanName] = '#FFFFFF';
                addColorRowToDOM(cleanName, '#FFFFFF');
            }
        }

        function addColorRowToDOM(colorName, colorValue) {
            const container = document.getElementById('colorTableEditor');
            const row = document.createElement('div');
            row.style.cssText = 'display: flex; align-items: center; gap: 5px; margin-bottom: 5px; padding: 3px; border: 1px solid #ddd; border-radius: 3px;';
            
            row.innerHTML = `
                <input type="text" value="${colorName}" onchange="updateColorName('${colorName}', this.value)" style="flex: 1; padding: 2px; border: 1px solid #ccc; border-radius: 3px; font-size: 11px;">
                <input type="color" value="${colorValue}" onchange="updateColorValue('${colorName}', this.value)" style="width: 30px; height: 20px; border: none; cursor: pointer;">
                <button onclick="deleteColorRow('${colorName}')" style="background: #dc3545; color: white; border: none; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 10px;">√ó</button>
            `;
            
            container.appendChild(row);
        }

        function updateColorName(oldName, newName) {
            if (newName && newName.trim() && newName !== oldName) {
                const cleanNewName = newName.trim();
                if (currentColorTable.hasOwnProperty(cleanNewName)) {
                    alert('Color name already exists!');
                    // Reset the input
                    event.target.value = oldName;
                    return;
                }
                currentColorTable[cleanNewName] = currentColorTable[oldName];
                delete currentColorTable[oldName];
                populateColorTable(); // Refresh the display
            }
        }

        function updateColorValue(colorName, newValue) {
            currentColorTable[colorName] = newValue;
        }

        function deleteColorRow(colorName) {
            if (confirm(`Delete color "${colorName}"?`)) {
                delete currentColorTable[colorName];
                populateColorTable(); // Refresh the display
            }
        }

        // ===== PRESET MANAGEMENT =====
        // Import preset manager functionality
        const DEFAULT_PRESET = {
            name: "Default",
            settings: {
                titleFont: "24px LolBeautfortBold",
                descriptionFont: "14px LolBeautfort",
                iconYOffset: 40,
                titleYOffset: 324,
                descriptionYOffset: 364,
                iconXOffset: 156,
                iconSize: 150,
                titleLineHeight: 26,
                descriptionLineHeight: 18,
                letterSpacing: 0.5,
                titleMaxWidth: 220,
                descriptionMaxWidth: 220
            }
        };

        class PresetManager {
            constructor() {
                this.currentPresetName = 'Default';
            }

            getAllPresets() {
                const customPresets = this.getCustomPresets();
                return [DEFAULT_PRESET, ...customPresets];
            }

            getCustomPresets() {
                try {
                    const stored = localStorage.getItem('augmentBuilder_presets');
                    return stored ? JSON.parse(stored) : [];
                } catch (e) {
                    console.error('Failed to load presets:', e);
                    return [];
                }
            }

            saveCustomPresets(presets) {
                try {
                    localStorage.setItem('augmentBuilder_presets', JSON.stringify(presets));
                    return true;
                } catch (e) {
                    console.error('Failed to save presets:', e);
                    return false;
                }
            }

            getCurrentPresetName() {
                try {
                    const stored = localStorage.getItem('augmentBuilder_currentPreset');
                    return stored || 'Default';
                } catch (e) {
                    return 'Default';
                }
            }

            setCurrentPresetName(name) {
                try {
                    localStorage.setItem('augmentBuilder_currentPreset', name);
                    this.currentPresetName = name;
                } catch (e) {
                    console.error('Failed to save current preset:', e);
                }
            }

            getPresetByName(name) {
                const allPresets = this.getAllPresets();
                return allPresets.find(preset => preset.name === name);
            }

            saveAsNewPreset(name, currentSettings) {
                if (!name || name.trim() === '') {
                    return { success: false, error: 'Preset name cannot be empty' };
                }

                if (name === 'Default') {
                    return { success: false, error: 'Cannot use "Default" as preset name' };
                }

                const customPresets = this.getCustomPresets();
                
                if (customPresets.some(preset => preset.name === name)) {
                    return { success: false, error: 'Preset name already exists' };
                }

                const newPreset = {
                    name: name,
                    settings: {
                        titleFont: currentSettings.titleFont,
                        descriptionFont: currentSettings.descriptionFont,
                        iconYOffset: currentSettings.iconYOffset,
                        titleYOffset: currentSettings.titleYOffset,
                        descriptionYOffset: currentSettings.descriptionYOffset,
                        iconXOffset: currentSettings.iconXOffset,
                        iconSize: currentSettings.iconSize,
                        titleLineHeight: currentSettings.titleLineHeight,
                        descriptionLineHeight: currentSettings.descriptionLineHeight,
                        letterSpacing: currentSettings.letterSpacing || 0.5,
                        titleMaxWidth: currentSettings.titleMaxWidth || 220,
                        descriptionMaxWidth: currentSettings.descriptionMaxWidth || 220
                    }
                };

                customPresets.push(newPreset);
                
                if (this.saveCustomPresets(customPresets)) {
                    this.setCurrentPresetName(name);
                    return { success: true };
                } else {
                    return { success: false, error: 'Failed to save preset' };
                }
            }

            updatePreset(name, currentSettings) {
                if (name === 'Default') {
                    return { success: false, error: 'Cannot update Default preset' };
                }

                const customPresets = this.getCustomPresets();
                const presetIndex = customPresets.findIndex(preset => preset.name === name);
                
                if (presetIndex === -1) {
                    return { success: false, error: 'Preset not found' };
                }

                customPresets[presetIndex].settings = {
                    titleFont: currentSettings.titleFont,
                    descriptionFont: currentSettings.descriptionFont,
                    iconYOffset: currentSettings.iconYOffset,
                    titleYOffset: currentSettings.titleYOffset,
                    descriptionYOffset: currentSettings.descriptionYOffset,
                    iconXOffset: currentSettings.iconXOffset,
                    iconSize: currentSettings.iconSize,
                    titleLineHeight: currentSettings.titleLineHeight,
                    descriptionLineHeight: currentSettings.descriptionLineHeight,
                    letterSpacing: currentSettings.letterSpacing || 0.5,
                    titleMaxWidth: currentSettings.titleMaxWidth || 220,
                    descriptionMaxWidth: currentSettings.descriptionMaxWidth || 220
                };

                if (this.saveCustomPresets(customPresets)) {
                    return { success: true };
                } else {
                    return { success: false, error: 'Failed to update preset' };
                }
            }

            deletePreset(name) {
                if (name === 'Default') {
                    return { success: false, error: 'Cannot delete Default preset' };
                }

                const customPresets = this.getCustomPresets();
                const filteredPresets = customPresets.filter(preset => preset.name !== name);
                
                if (filteredPresets.length === customPresets.length) {
                    return { success: false, error: 'Preset not found' };
                }

                if (this.saveCustomPresets(filteredPresets)) {
                    if (this.getCurrentPresetName() === name) {
                        this.setCurrentPresetName('Default');
                    }
                    return { success: true };
                } else {
                    return { success: false, error: 'Failed to delete preset' };
                }
            }

            applyPreset(presetName, settingsObject) {
                const preset = this.getPresetByName(presetName);
                if (!preset) {
                    console.error('Preset not found:', presetName);
                    return false;
                }

                Object.keys(preset.settings).forEach(key => {
                    settingsObject[key] = preset.settings[key];
                });

                this.updateUIFromSettings(preset.settings);
                this.setCurrentPresetName(presetName);
                
                return true;
            }

            updateUIFromSettings(settings) {
                const titleFontInput = document.getElementById('titleFontInput');
                if (titleFontInput) titleFontInput.value = settings.titleFont;

                const descriptionFontInput = document.getElementById('descriptionFontInput');
                if (descriptionFontInput) descriptionFontInput.value = settings.descriptionFont;

                const sliderMappings = {
                    iconYOffset: 'iconYOffset',
                    titleYOffset: 'titleYOffset',
                    descriptionYOffset: 'descriptionYOffset',
                    iconXOffset: 'iconXOffset',
                    iconSize: 'iconSize',
                    titleLineHeight: 'titleLineHeight',
                    descriptionLineHeight: 'descriptionLineHeight'
                };

                Object.keys(sliderMappings).forEach(settingKey => {
                    const slider = document.getElementById(sliderMappings[settingKey]);
                    if (slider) {
                        slider.value = settings[settingKey];
                        
                        const output = document.querySelector(`output[for="${sliderMappings[settingKey]}"]`);
                        if (output) {
                            output.value = settings[settingKey];
                        }
                    }
                });
            }
        }

        const presetManager = new PresetManager();

        // Preset UI functions
        function populatePresetDropdown() {
            const presetSelect = document.getElementById('presetSelect');
            const allPresets = presetManager.getAllPresets();
            
            presetSelect.innerHTML = '';
            allPresets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.name;
                option.textContent = preset.name;
                presetSelect.appendChild(option);
            });
            
            const currentPreset = presetManager.getCurrentPresetName();
            presetSelect.value = currentPreset;
        }

        function selectPreset(presetName) {
            if (presetManager.applyPreset(presetName, settings)) {
                mergeAugmentImages();
            }
        }

        function saveNewPreset() {
            const name = prompt('Enter preset name:');
            if (name) {
                const result = presetManager.saveAsNewPreset(name, settings);
                if (result.success) {
                    populatePresetDropdown();
                    document.getElementById('presetSelect').value = name;
                    showToast('Preset saved');
                } else {
                    showToast('Error: ' + result.error, true);
                }
            }
        }

        function updateCurrentPreset() {
            const currentPreset = presetManager.getCurrentPresetName();
            if (currentPreset === 'Default') {
                showToast('Cannot update Default preset', true);
                return;
            }
            
            const result = presetManager.updatePreset(currentPreset, settings);
            if (result.success) {
                showToast('Preset updated');
            } else {
                showToast('Error: ' + result.error, true);
            }
        }

        function deleteCurrentPreset() {
            const currentPreset = presetManager.getCurrentPresetName();
            if (currentPreset === 'Default') {
                showToast('Cannot delete Default preset', true);
                return;
            }
            
            if (confirm(`Delete preset "${currentPreset}"? This cannot be undone.`)) {
                const result = presetManager.deletePreset(currentPreset);
                if (result.success) {
                    populatePresetDropdown();
                    selectPreset('Default');
                    showToast('Preset deleted');
                } else {
                    showToast('Error: ' + result.error, true);
                }
            }
        }

        // ===== ITEMS AND MODIFIERS DATA =====
        const itemIconsBaseUrl = "https://raw.communitydragon.org/pbe/game/assets/items/icons2d/";
        const arenaItemIconsBaseUrl = "https://raw.communitydragon.org/pbe/game/assets/items/icons2d/autoatlas/xlborderedicons/";
        const itemModifiersBaseUrl = "https://raw.communitydragon.org/pbe/game/assets/items/itemmodifiers/";
        const aramMayhemAugmentsBaseUrl = "https://raw.communitydragon.org/pbe/game/assets/ux/kiwi/augments/icons/";

        const itemsDataArray = [
            { name: "Eye of the Observer", filename: "096_eye_of_the_observer.png", id: 1 },
            { name: "Boots of Speed", filename: "1001_class_t1_bootsofspeed.png", id: 2 },
            { name: "Faerie Charm", filename: "1004_class_t1_faeriecharm.png", id: 3 },
            { name: "Rejuvenation Bead", filename: "1006_tank_t1_rejuvenationbead.png", id: 4 },
            { name: "Giant's Belt", filename: "1011_class_t2_giantsbelt.png", id: 5 },
            { name: "Cloak of Agility", filename: "1018_base_t1_cloakagility.png", id: 6 },
            { name: "Blasting Wand", filename: "1026_mage_t1_blastingwand.png", id: 7 },
            { name: "Sapphire Crystal", filename: "1027_base_t1_saphirecrystal.png", id: 8 },
            { name: "Ruby Crystal", filename: "1028_base_t1_rubycrystal.png", id: 9 },
            { name: "Cloth Armor", filename: "1029_base_t1_clotharmor.png", id: 10 },
            { name: "Chain Vest", filename: "1031_base_t2_chainvest.png", id: 11 },
            { name: "Null-Magic Mantle", filename: "1033_base_t1_magicmantle.png", id: 12 },
            { name: "Emberknife", filename: "1035_alll_t1_emberknife.png", id: 13 },
            { name: "Long Sword", filename: "1036_class_t1_longsword.png", id: 14 },
            { name: "Pickaxe", filename: "1037_class_t1_pickaxe.png", id: 15 },
            { name: "B.F. Sword", filename: "1038_marksman_t1_bfsword.png", id: 16 },
            { name: "Hailblade", filename: "1039_all_t1_hailblade.png", id: 17 },
            { name: "Obsidian Edge", filename: "1040_obsidianedge.png", id: 18 },
            { name: "Dagger", filename: "1042_base_t1_dagger.png", id: 19 },
            { name: "Recurve Bow", filename: "1043_base_t2_recurvebow.png", id: 20 },
            { name: "Amplifying Tome", filename: "1052_mage_t2_amptome.png", id: 21 },
            { name: "Vampiric Scepter", filename: "1053_fighter_t2_vampiricscepter.png", id: 22 },
            { name: "Doran's Shield", filename: "1054_tank_t1_doransshield.png", id: 23 },
            { name: "Doran's Blade", filename: "1055_marksman_t1_doransblade.png", id: 24 },
            { name: "Doran's Ring", filename: "1056_mage_t1_doransring.png", id: 25 },
            { name: "Negatron Cloak", filename: "1057_tank_t2_negatroncloak.png", id: 26 },
            { name: "Needlessly Large Rod", filename: "1058_mage_t1_largerod.png", id: 27 },
            { name: "Dark Seal", filename: "1082_mage_t1_darkseal.png", id: 28 },
            { name: "Cull", filename: "1083_marksman_t1_cull.png", id: 29 },
            { name: "Scorchclaw Pup", filename: "1101_jungle_t1_scorchclawpup.png", id: 30 },
            { name: "Gustwalker Hatchling", filename: "1102_jungle_t1_gustwalkerhatchling.png", id: 31 },
            { name: "Mosstomper Seedling", filename: "1103_jungle_t1_mosstomperseedling.png", id: 32 },
            { name: "Test Item 2", filename: "1103_testitem2.png", id: 33 },
            { name: "Enchantment: Runeglaive", filename: "1402_enchantment_runeglaive.png", id: 34 },
            { name: "Turret Shielder", filename: "1504_turretshielder.png", id: 35 },
            { name: "Sudden Death", filename: "1507_tournament_suddendeath.png", id: 36 },
            { name: "Anti-Tower Socks", filename: "1508_antitowersocks.png", id: 37 },
            { name: "Gusto", filename: "1509_gusto.png", id: 38 },
            { name: "Phreakish Gusto", filename: "1510_phreakishgusto.png", id: 39 },
            { name: "Super Mech Armor", filename: "1511_supermecharmor.png", id: 40 },
            { name: "Super Mech Power Field", filename: "1512_supermechpowerfield.png", id: 41 },
            { name: "Health Potion", filename: "2003_class_t1_healthpotion.png", id: 42 },
            { name: "Total Biscuit of Everlasting Will", filename: "2010_class_t1_totalbiscuitofeverlastingwill.png", id: 43 },
            { name: "Tunneler", filename: "2012_tunneler.png", id: 44 },
            { name: "Kircheis Shard", filename: "2015_marksman_t2_kirkcheisshard.png", id: 45 },
            { name: "Steel Sigil", filename: "2019_steel_sigil.png", id: 46 },
            { name: "The Brutalizer", filename: "2020_thebrutalizer.png", id: 47 },
            { name: "Glowing Mote", filename: "2022_glowingmote.png", id: 48 },
            { name: "Sharpening Stone", filename: "2030_sharpening_stone.png", id: 49 },
            { name: "Refillable Potion", filename: "2031_class_t1_refillablepotion.png", id: 50 },
            { name: "Corrupting Potion", filename: "2033_class_t1_corruptingpotion.png", id: 51 },
            { name: "Ichor of Illumination", filename: "2048_ichorofillumination.png", id: 52 },
            { name: "Guardian's Amulet", filename: "2049_guardiansamulet.png", id: 53 },
            { name: "Sightstone", filename: "2049_sightstone.png", id: 54 },
            { name: "Guardian's Horn", filename: "2051_aram_t1_guardianshorn.png", id: 55 },
            { name: "Poro-Snax", filename: "2052_poro_snack.png", id: 56 },
            { name: "Control Ward", filename: "2055_class_t1_controlward.png", id: 57 },
            { name: "Shurelya's Battlesong", filename: "2065_enchanter_t4_shurelyasbattlesong.png", id: 58 },
            { name: "Shurelya's Battlesong", filename: "2065_tank_t4_shurelyasbattlesong.png", id: 59 },
            { name: "Elixir of Iron", filename: "2138_class_elixirofiron.png", id: 60 },
            { name: "Elixir of Iron", filename: "2138_elixir_of_iron.png", id: 61 },
            { name: "Elixir of Sorcery", filename: "2139_class_t1_elixirofsorcery.png", id: 62 },
            { name: "Elixir of Wrath", filename: "2140_class_t0_elixirofwrath.png", id: 63 },
            { name: "Stat Anvil", filename: "220000_statanvil.png", id: 64 },
            { name: "Fighter Anvil", filename: "220001_fighteranvil.png", id: 65 },
            { name: "Marksman Anvil", filename: "220002_marksmananvil.png", id: 66 },
            { name: "Assassin Anvil", filename: "220003_assassinanvil.png", id: 67 },
            { name: "Mage Anvil", filename: "220004_mageanvil.png", id: 68 },
            { name: "Tank Anvil", filename: "220005_tankanvil.png", id: 69 },
            { name: "Support Anvil", filename: "220006_supportanvil.png", id: 70 },
            { name: "Prismatic Anvil", filename: "220007_prismaticanvil.png", id: 71 },
            { name: "Sack of Gold", filename: "2319_sackofgold.png", id: 72 },
            { name: "Minion Dematerializer", filename: "2403_minion_dematerializer.png", id: 73 },
            { name: "Shattered Armguard", filename: "2420_shatteredarmguard.png", id: 74 },
            { name: "Slightly Magical Boots", filename: "2422_class_t1_slightlymagicalboots.png", id: 75 },
            { name: "Unending Despair", filename: "2502_unendingdespair.png", id: 76 },
            { name: "Blackfire Torch", filename: "2503_blackfiretorch64.png", id: 77 },
            { name: "Kaenic Rookern", filename: "2504_kaenicrookern.png", id: 78 },
            { name: "Fated Ashes", filename: "2508_fatedashes64.png", id: 79 },
            { name: "Abyssal Scepter", filename: "3001_abyssal_scepter.png", id: 80 },
            { name: "Lunari Support", filename: "3001_support_lunari.png", id: 81 },
            { name: "Trailblazer", filename: "3002_trailblazer.png", id: 82 },
            { name: "Archangel's Staff", filename: "3003_mage_t3_archangelstaff.png", id: 83 },
            { name: "Manamune", filename: "3004_marksman_t3_manamune.png", id: 84 },
            { name: "Atma's Reckoning", filename: "3005_fighter_t3_atmasreckoning.png", id: 85 },
            { name: "Berserker's Greaves", filename: "3006_class_t2_berserkersgreaves.png", id: 86 },
            { name: "Boots of Swiftness", filename: "3009_class_t2_bootsofswiftness.png", id: 87 },
            { name: "Void Boots", filename: "3010_voidboots.png", id: 88 },
            { name: "Voidwalkers", filename: "3010_voidwalkers.png", id: 89 },
            { name: "Chemtech Fumigator", filename: "3011_enchanter_t3_chemtechfumigator.png", id: 90 },
            { name: "Blessed Chalice", filename: "3012_blessed_chalice.png", id: 91 },
            { name: "Sorcerer's Shoes", filename: "3020_class_t2_sorcerersshoes.png", id: 92 },
            { name: "Frozen Mallet", filename: "3022_frozen_mallet.png", id: 93 },
            { name: "Lifewell Pendant", filename: "3023_lifewell_pendant.png", id: 94 },
            { name: "Glacial Shroud", filename: "3024_tank_t2_glacialshroud.png", id: 95 },
            { name: "Guardian Angel", filename: "3026_fighter_t3_guardianangel.png", id: 96 },
            { name: "Infinity Edge", filename: "3031_marksman_t3_infinityedge.png", id: 97 },
            { name: "Innervating Locket", filename: "3032_innervating_locket.png", id: 98 },
            { name: "Yun Tal Wildarrows", filename: "3032_yuntalwildarrows.png", id: 99 },
            { name: "Mortal Reminder", filename: "3033_marksman_t3_mortalreminder.png", id: 100 },
            { name: "Kenyu's Kukri", filename: "3034_kenyus_kukri.png", id: 101 },
            { name: "Last Whisper", filename: "3035_marksman_t2_lastwhisper.png", id: 102 },
            { name: "Lord Dominik's Regards", filename: "3036_marksman_t3_dominikregards.png", id: 103 },
            { name: "Mejai's Soulstealer", filename: "3041_mage_t2_mejaissoulstealer.png", id: 104 },
            { name: "Muramana", filename: "3042_marksman_t3_muramana.png", id: 105 },
            { name: "Netherrift Armor", filename: "3042_netherrift_armor.png", id: 106 },
            { name: "Phage", filename: "3044_fighter_t2_phage.png", id: 107 },
            { name: "Phantom Dancer", filename: "3046_marksman_t3_phantomdancer.png", id: 108 },
            { name: "Plated Steelcaps", filename: "3047_class_t2_ninjatabi.png", id: 109 },
            { name: "Seraph's Embrace", filename: "3048_mage_t3_seraphsembrace.png", id: 110 },
            { name: "Zeke's Convergence", filename: "3050_enchanter_t3_zekesconvergence.png", id: 111 },
            { name: "Axe of Avarosa", filename: "3051_fighter_t2_axeofavarosa.png", id: 112 },
            { name: "Sterak's Gage", filename: "3053_steraks_gage.png", id: 113 },
            { name: "Silversteel Talons", filename: "3054_silversteeltalons.png", id: 114 },
            { name: "Fulmination", filename: "3055_fulmination.png", id: 115 },
            { name: "Demon King's Crown", filename: "3056_demonkingscrown.png", id: 116 },
            { name: "Ohmwrecker", filename: "3056_ohmwrecker.png", id: 117 },
            { name: "Sheen", filename: "3057_fighter_t2_sheen.png", id: 118 },
            { name: "Shield of Molten Stone", filename: "3058_shieldofmoltenstone.png", id: 119 },
            { name: "Cloak of Starry Night", filename: "3059_cloakofstarrynight.png", id: 120 },
            { name: "Force of Entropy", filename: "3061_forceofentropy.png", id: 121 },
            { name: "Sanguine Gift", filename: "3062_sanguinegift.png", id: 122 },
            { name: "Elisha's Miracle", filename: "3063_elishasmiracle.png", id: 123 },
            { name: "Spike the Ripper", filename: "3064_spike_the_ripper.png", id: 124 },
            { name: "Talisman of Ascension", filename: "3064_talismanofascension.png", id: 125 },
            { name: "Spirit Visage", filename: "3065_tank_t3_spiritvisage.png", id: 126 },
            { name: "Winged Moonplate", filename: "3066_tank_t3_wingedmoonplate.png", id: 127 },
            { name: "Kindlegem", filename: "3067_tank_t1_kindlegem.png", id: 128 },
            { name: "Sunfire Aegis", filename: "3068_tank_t4_sunfireaegis.png", id: 129 },
            { name: "Hamstringer", filename: "3069_hamstringer.png", id: 130 },
            { name: "Tear of the Goddess", filename: "3070_all_t1_tearofthegoddess.png", id: 131 },
            { name: "Black Cleaver", filename: "3071_fighter_t3_blackcleaver.png", id: 132 },
            { name: "Bloodthirster", filename: "3072_fighter_t3_bloodthirster.png", id: 133 },
            { name: "Hexaegis", filename: "3073_hexaegis.png", id: 134 },
            { name: "Ravenous Hydra", filename: "3074_fighter_t3_ravenoushydra.png", id: 135 },
            { name: "Thornmail", filename: "3075_tank_t3_thornmail.png", id: 136 },
            { name: "Bramble Vest", filename: "3076_tank_t2_bramblevest.png", id: 137 },
            { name: "Tiamat", filename: "3077_fighter_t2_tiamat.png", id: 138 },
            { name: "Trinity Force", filename: "3078_fighter_t4_trinityforce.png", id: 139 },
            { name: "Warden's Mail", filename: "3082_tank_t2_wardensmail.png", id: 140 },
            { name: "Warmog's Armor", filename: "3083_tank_t3_warmogs.png", id: 141 },
            { name: "Heartsteel", filename: "3084_tank_t4_heartsteel.png", id: 142 },
            { name: "Runaan's Hurricane", filename: "3085_marksman_t3_runaans.png", id: 143 },
            { name: "Zeal", filename: "3086_fighter_t2_zeal.png", id: 144 },
            { name: "Statikk Shiv", filename: "3087_statikk_shiv.png", id: 145 },
            { name: "Rabadon's Deathcap", filename: "3089_mage_t3_deathcap.png", id: 146 },
            { name: "Wit's End", filename: "3091_fighter_t3_witsend.png", id: 147 },
            { name: "Rapid Firecannon", filename: "3094_marksman_t3_rapidfirehandcannon.png", id: 148 },
            { name: "Windblade", filename: "3095_windblade.png", id: 149 },
            { name: "Lich Bane", filename: "3100_mage_t3_lichbane.png", id: 150 },
            { name: "Banshee's Veil", filename: "3102_mage_t3_bansheesveil.png", id: 151 },
            { name: "Aegis of the Legion", filename: "3105_tank_t2_aegisofthelegion.png", id: 152 },
            { name: "Redemption", filename: "3107_enchanter_t3_redemption.png", id: 153 },
            { name: "Fiendish Codex", filename: "3108_mage_t2_fiendishcodex.png", id: 154 },
            { name: "Knight's Vow", filename: "3109_tank_t3_knightsvow.png", id: 155 },
            { name: "Frozen Heart", filename: "3110_tank_t3_frozenheart.png", id: 156 },
            { name: "Mercury's Treads", filename: "3111_class_t2_mercurystreads.png", id: 157 },
            { name: "Guardian's Orb", filename: "3112_aram_t1_guardiansorb.png", id: 158 },
            { name: "Aether Wisp", filename: "3113_mage_t2_aetherwisp.png", id: 159 },
            { name: "Forbidden Idol", filename: "3114_mage_t2_forbiddenidol.png", id: 160 },
            { name: "Nashor's Tooth", filename: "3115_mage_t3_nashorstooth.png", id: 161 },
            { name: "Rylai's Crystal Scepter", filename: "3116_mage_t3_rylajscrystalscepter.png", id: 162 },
            { name: "Boots of Mobility", filename: "3117_class_t2_bootsofmobility.png", id: 163 },
            { name: "Malignance", filename: "3118_malignance.png", id: 164 },
            { name: "Winter's Approach", filename: "3119_wintersapproach.png", id: 165 },
            { name: "Fimbulwinter", filename: "3121_fimbulwinter.png", id: 166 },
            { name: "Executioner's Calling", filename: "3123_fighter_t2_executionerscalling.png", id: 167 },
            { name: "Guinsoo's Rageblade", filename: "3124_marksman_t3_guinsoosrageblade.png", id: 168 },
            { name: "Deathfire Grasp", filename: "3128_deathfire_grasp.png", id: 169 },
            { name: "Sword of the Divine", filename: "3131_fighter_t3_swordofthedivine.png", id: 170 },
            { name: "Caulfield's Warhammer", filename: "3133_fighter_t2_caulfieldswarhammer.png", id: 171 },
            { name: "Serrated Dirk", filename: "3134_assassin_t2_serrateddirk.png", id: 172 },
            { name: "Void Staff", filename: "3135_mage_t3_voidstaff.png", id: 173 },
            { name: "Cryptbloom", filename: "3137_cryptbloom.png", id: 174 },
            { name: "Mercurial Scimitar", filename: "3139_marksman_t3_mercurialscimitar.png", id: 175 },
            { name: "Quicksilver Sash", filename: "3140_marksman_t2_quicksilversash.png", id: 176 },
            { name: "Youmuu's Ghostblade", filename: "3142_assassin_t3_youmuusghostblade.png", id: 177 },
            { name: "Randuin's Omen", filename: "3143_tank_t3_randuinsomen.png", id: 178 },
            { name: "Scout's Slingshot", filename: "3144_scoutslingshot.png", id: 179 },
            { name: "Hextech Alternator", filename: "3145_mage_t2_hextechalternator.png", id: 180 },
            { name: "Hextech Gunblade", filename: "3146_hextechgunblade.png", id: 181 },
            { name: "Haunting Guise", filename: "3147_hauntingguise.png", id: 182 },
            { name: "Hextech Rocketbelt", filename: "3152_mage_t4_hextechrocketbelt.png", id: 183 },
            { name: "Blade of the Ruined King", filename: "3153_fighter_t3_bladeoftheruinedking.png", id: 184 },
            { name: "Wriggle's Lantern", filename: "3154_wriggleslantern.png", id: 185 },
            { name: "Hexdrinker", filename: "3155_fighter_t2_hexdrinker.png", id: 186 },
            { name: "Maw of Malmortius", filename: "3156_fighter_t3_mawofmalmortius.png", id: 187 },
            { name: "Zhonya's Hourglass", filename: "3157_mage_t3_zhonyashourglass.png", id: 188 },
            { name: "Ionian Boots of Lucidity", filename: "3158_class_t2_ionianbootsoflucidity.png", id: 189 },
            { name: "Spear of Shojin", filename: "3161_fighter_t3_spearofshojin.png", id: 190 },
            { name: "Morellonomicon", filename: "3165_mage_t3_morellonomicon.png", id: 191 },
            { name: "Zephyr", filename: "3172_zephyr.png", id: 192 },
            { name: "Guardian's Blade", filename: "3177_aram_t1_guardiansblade.png", id: 193 },
            { name: "Guardian's Hammer", filename: "3177_aram_t1_guardianshammer.png", id: 194 },
            { name: "Umbral Glaive", filename: "3179_assassin_t3_umbralglaive.png", id: 195 },
            { name: "Hullbreaker", filename: "3181_hullbreaker.png", id: 196 },
            { name: "Sanguine Blade", filename: "3181_sanguineblade.png", id: 197 },
            { name: "Locket of the Iron Solari", filename: "3190_enchanter_t4_locketofironsolari.png", id: 198 },
            { name: "Seeker's Armguard", filename: "3191_battlemage_t2_seekersarmguard.png", id: 199 },
            { name: "Gargoyle Stoneplate (Old)", filename: "3193_gargoyle_stoneplate.png", id: 200 },
            { name: "Gargoyle Stoneplate", filename: "3193_tank_t3_gargoylestoneplate.png", id: 201 },
            { name: "Battlemage Blocker", filename: "3194_battlemage_blocker.png", id: 202 },
            { name: "Hexcore 2", filename: "3196_hexcore2.png", id: 203 },
            { name: "Hexcore 3", filename: "3197_hexcore3.png", id: 204 },
            { name: "Hexcore 4", filename: "3198_hexcore4.png", id: 205 },
            { name: "Spectre's Cowl", filename: "3211_tank_t2_spectrescowl.png", id: 206 },
            { name: "Mikael's Blessing", filename: "3222_enchanter_t3_mikaelsblessing.png", id: 207 },
            { name: "Terminus", filename: "3302_terminus.png", id: 208 },
            { name: "Stealth Ward", filename: "3340_class_t1_wardingtotem.png", id: 209 },
            { name: "Arcane Sweeper", filename: "3348_arcanesweeper.png", id: 210 },
            { name: "Farsight Alteration", filename: "3363_class_t1_farsightalteration.png", id: 211 },
            { name: "Oracle Lens", filename: "3364_class_t1_oracleslens.png", id: 212 },
            { name: "The Forge Cleaver", filename: "3380_the_forge_cleaver.png", id: 213 },
            { name: "Wooglet's Witchcap", filename: "3385_forge_wooglets_witchcap.png", id: 214 },
            { name: "Bonetooth Necklace R", filename: "3406_bonetooth_necklace_r_2.png", id: 215 },
            { name: "Bonetooth Necklace G", filename: "3417_bonetooth_necklace_g_1.png", id: 216 },
            { name: "Rite of Ruin", filename: "3430_riteofruin.png", id: 217 },
            { name: "ASC Trinket", filename: "3460_asc_trinket.png", id: 218 },
            { name: "Ardent Censer", filename: "3504_enchanter_t3_ardentcenser.png", id: 219 },
            { name: "Essence Reaver", filename: "3508_marksman_t3_essencereaver.png", id: 220 },
            { name: "ZZ'Rot Portal", filename: "3512_zzrot_portal.png", id: 221 },
            { name: "Eye of the Herald", filename: "3513_eyeoftheherald.png", id: 222 },
            { name: "Kalista's Passive Item", filename: "3599_kalistapassiveitem.png", id: 223 },
            { name: "Black Spear", filename: "3600_champ_t0_blackspear.png", id: 224 },
            { name: "Laser Affix", filename: "3634_laser_affix.png", id: 225 },
            { name: "Spicy Snax", filename: "3681_spicysnax.png", id: 226 },
            { name: "Rainbow Snax", filename: "3683_rainbowsnax.png", id: 227 },
            { name: "Dead Man's Plate", filename: "3742_tank_t3_deadmansplate.png", id: 228 },
            { name: "Staff of Flowing Water", filename: "3744_enchanter_t3_staffofflowingwater.png", id: 229 },
            { name: "Titanic Hydra", filename: "3748_fighter_t3_titanichydra.png", id: 230 },
            { name: "Titanic Hydra (Old)", filename: "3748_titanic_hydra.png", id: 231 },
            { name: "Bami's Cinder", filename: "3751_bamis_cinder.png", id: 232 },
            { name: "Crystalline Bracer", filename: "3801_tank_t2_crystallinebracer.png", id: 233 },
            { name: "Lost Chapter", filename: "3802_mage_tier2_lostchapter.png", id: 234 },
            { name: "Catalyst of Aeons", filename: "3803_mage_t2_catalystofaeons.png", id: 235 },
            { name: "Edge of Night", filename: "3814_assassin_t3_edgeofnight.png", id: 236 },
            { name: "Spellthief's Edge", filename: "3850_mage_t1_spellthiefsedge.png", id: 237 },
            { name: "Frostfang", filename: "3851_mage_t2_frostfang.png", id: 238 },
            { name: "Shard of True Ice", filename: "3853_mage_t3_shardoftrueice.png", id: 239 },
            { name: "Petricide Shoulderguard", filename: "3854_tank_t1_petriciteshoulderguard.png", id: 240 },
            { name: "Runesteel Spaulders", filename: "3855_tank_t2_runesteelspaulders.png", id: 241 },
            { name: "Pauldrons of Whiterock", filename: "3857_tank_t3_pauldronsofwhiterock.png", id: 242 },
            { name: "Relic Shield", filename: "3858_tank_t1_relicshield.png", id: 243 },
            { name: "Targon's Buckler", filename: "3859_tank_t2_targonsbucker.png", id: 244 },
            { name: "Bulwark of the Mountain", filename: "3860_tank_t3_bulwarkofthemountain.png", id: 245 },
            { name: "Spectral Sickle", filename: "3862_marksman_t1_spectralsickle.png", id: 246 },
            { name: "Harrowing Crescent", filename: "3863_marksman_t2_harrowingcrescent.png", id: 247 },
            { name: "Black Mist Scythe", filename: "3864_marksman_t3_blackmistscythe.png", id: 248 },
            { name: "World Atlas", filename: "3865_worldatlas.png", id: 249 },
            { name: "Runic Compass", filename: "3866_runiccompass.png", id: 250 },
            { name: "Bounty of Worlds", filename: "3867_bountyofworlds.png", id: 251 },
            { name: "Celestial Opposition", filename: "3869_celestialopposition.png", id: 252 },
            { name: "Dreammaker", filename: "3870_dreammaker.png", id: 253 },
            { name: "Zaz'Zak's Realmspike", filename: "3871_zazzaksrealmspike.png", id: 254 },
            { name: "Solstice Sleigh", filename: "3876_solticesleigh.png", id: 255 },
            { name: "Bloodsong", filename: "3877_bloodsong.png", id: 256 },
            { name: "Fire at Will Circle", filename: "3901_champ_t0_fireatwillcircle.png", id: 257 },
            { name: "Death's Daughter Circle", filename: "3902_champ_t0_deathsdaughtercircle.png", id: 258 },
            { name: "Raise Morale Circle", filename: "3903_champ_t0_raisemoralecircle.png", id: 259 },
            { name: "Gangplank R3", filename: "3903_gangplankr3.png", id: 260 },
            { name: "Oblivion Orb", filename: "3916_mage_t2_oblivionorb.png", id: 261 },
            { name: "Ghostwalkers", filename: "4001_ghostwalkers.png", id: 262 },
            { name: "Lifeline", filename: "4003_assassin_t2_lifeline.png", id: 263 },
            { name: "Spectral Cutlass", filename: "4004_assassin_t3_spectralcutlass.png", id: 264 },
            { name: "Imperial Mandate", filename: "4005_enchanter_t4_imperialmandate.png", id: 265 },
            { name: "Bloodletter's Veil", filename: "4010_bloodlettersveil.png", id: 266 },
            { name: "Sword of Blossoming Dawn", filename: "4011_swordofblossomingdawn.png", id: 267 },
            { name: "Sin Eater", filename: "4012_sineater.png", id: 268 },
            { name: "Lightning Braid", filename: "4013_lightning_braid.png", id: 269 },
            { name: "Perplexity", filename: "4015_perplexity.png", id: 270 },
            { name: "Wordless Promise", filename: "4016_wordlesspromise.png", id: 271 },
            { name: "Hellfire Hatchet", filename: "4017_hellfirehatchet.png", id: 272 },
            { name: "Force of Nature", filename: "4401_tank_t3_forceofnature.png", id: 273 },
            { name: "Golden Spatula", filename: "4403_goldenspatula.png", id: 274 },
            { name: "Twin Masks", filename: "443080_twinmasks.png", id: 275 },
            { name: "Hexbolt Companion", filename: "443081_hexboltcompanion.png", id: 276 },
            { name: "Reaper's Toll", filename: "443090_reaperstoll.png", id: 277 },
            { name: "Reverberation", filename: "447114_reverberation.png", id: 278 },
            { name: "Regicide", filename: "447115_regicide.png", id: 279 },
            { name: "Kinkou Jitte", filename: "447116_kinkoujitte.png", id: 280 },
            { name: "Pyromancer's Cloak", filename: "447118_pyromancerscloak.png", id: 281 },
            { name: "Lightning Rod", filename: "447119_lightningrod.png", id: 282 },
            { name: "Diamond-Tipped Spear", filename: "447120_diamondtippedspear.png", id: 283 },
            { name: "Twilight's Edge", filename: "447121_twilightsedge.png", id: 284 },
            { name: "Black Hole Gauntlet", filename: "447122_blackholegauntlet.png", id: 285 },
            { name: "Puppeteer", filename: "447123_puppeteer.png", id: 286 },
            { name: "Horizon Focus", filename: "4628_mage_t3_horizonfocus.png", id: 287 },
            { name: "Cosmic Drive", filename: "4629_mage_t3_cosmicdrive.png", id: 288 },
            { name: "Void Crystal", filename: "4630_mage_t2_voidcrystal.png", id: 289 },
            { name: "Verdant Barrier", filename: "4632_tank_t2_verdantbarrier.png", id: 290 },
            { name: "Riftmaker", filename: "4633_mage_t4_riftmaker.png", id: 291 },
            { name: "Leeching Leer", filename: "4635_mage_t2_leechingleer.png", id: 292 },
            { name: "Night Harvester", filename: "4636_mage_t4_nightharvester.png", id: 293 },
            { name: "Demonic Embrace", filename: "4637_mage_t3_demonicembrace.png", id: 294 },
            { name: "Watchful Sightstone", filename: "4638_enchanter_t3_watchfulsightstone.png", id: 295 },
            { name: "Stirring Sightstone", filename: "4641_enchanter_t2_stirringsightstone.png", id: 296 },
            { name: "Bandleglass Mirror", filename: "4642_enchanter_t2_bandleglassmirror.png", id: 297 },
            { name: "Vigilant Sightstone", filename: "4643_enchanter_t3_vigilantsightstone.png", id: 298 },
            { name: "Crown of the Shattered Queen", filename: "4644_crown.png", id: 299 },
            { name: "Shadowflame", filename: "4645_shadowflame.png", id: 300 },
            { name: "Stormsurge", filename: "4646_stormsurge.png", id: 301 },
            { name: "Iron Spike Whip", filename: "6029_fighter_t2_ironspikewhip.png", id: 302 },
            { name: "Cruelty", filename: "6035_fighter_t3_silvermeredawn.png", id: 303 },
            { name: "Death's Dance", filename: "6333_fighter_t3_deathsdance.png", id: 304 },
            { name: "Chempunk Chainsword", filename: "6609_fighter_t3_chempunkchainsword.png", id: 305 },
            { name: "Sundered Sky", filename: "6610_sunderedsky.png", id: 306 },
            { name: "Moonstone Renewer", filename: "6617_enchanter_t4_moonstonerenewer.png", id: 307 },
            { name: "Echoes of Helia", filename: "6620_echoes_of_helia.png", id: 308 },
            { name: "Dawncore", filename: "6621_dawncore.png", id: 309 },
            { name: "Goredrinker", filename: "6630_fighter_t4_goredrinker.png", id: 310 },
            { name: "Stridebreaker", filename: "6631_fighter_t4_stridebreaker.png", id: 311 },
            { name: "Divine Devourer", filename: "6632_fighter_t4_divinedevourer.png", id: 312 },
            { name: "Liandry's Anguish", filename: "6653_mage_t4_liandrysanguish.png", id: 313 },
            { name: "Caster's Companion", filename: "6655_casterscompanion.png", id: 314 },
            { name: "Everfrost", filename: "6656_mage_t4_everfrost.png", id: 315 },
            { name: "Rod of Ages", filename: "6657_mage_t4_rodofages.png", id: 316 },
            { name: "Bami's Cinder", filename: "6660_tank_t2_bamiscinder.png", id: 317 },
            { name: "Iceborn Gauntlet", filename: "6662_tank_t3_iceborngauntlet.png", id: 318 },
            { name: "Hollow Radiance", filename: "6664_hollowradiance.png", id: 319 },
            { name: "Chemtech Purifier", filename: "6664_tank_t4_acceleratedchemtank.png", id: 320 },
            { name: "Jak'Sho, The Protean", filename: "6665_tank_t4_jakshotheprotean.png", id: 321 },
            { name: "Radiant Virtue", filename: "6667_tank_t4_radiantvirtue.png", id: 322 },
            { name: "Noonquiver", filename: "6670_marksman_t2_noonquiver.png", id: 323 },
            { name: "Galeforce", filename: "6671_marksman_t4_galeforce.png", id: 324 },
            { name: "Kraken Slayer", filename: "6672_marksman_t4_behemothslayer.png", id: 325 },
            { name: "Immortal Shieldbow", filename: "6673_marksman_t4_crimsonshieldbow.png", id: 326 },
            { name: "Navori Quickblades", filename: "6675_marksman_t3_navoriquickblades.png", id: 327 },
            { name: "Navori Flickerblade", filename: "6675_navoriflickerblade.png", id: 328 },
            { name: "The Collector", filename: "6676_marksman_t3_thecollector.png", id: 329 },
            { name: "Rage Knife", filename: "6677_marksman_t2_rageknife.png", id: 330 },
            { name: "Rectrix", filename: "6690_rectrix.png", id: 331 },
            { name: "Duskblade of Draktharr", filename: "6691_assassin_t4_duskbladeofdraktharr.png", id: 332 },
            { name: "Eclipse", filename: "6692_assassin_t4_eclipse.png", id: 333 },
            { name: "Prowler's Claw", filename: "6693_assassin_t4_prowlersclaw.png", id: 334 },
            { name: "Serylda's Grudge", filename: "6694_assasin_t3_seryldasgrudge.png", id: 335 },
            { name: "Serpent's Fang", filename: "6695_assassin_t3_serpentsfang.png", id: 336 },
            { name: "Axiom Arc", filename: "6696_axiomarc.png", id: 337 },
            { name: "Hubris", filename: "6697_hubris.png", id: 338 },
            { name: "Profane Hydra", filename: "6698_profanehydra.png", id: 339 },
            { name: "Voltaic Cyclosword", filename: "6699_voltaiccyclosword.png", id: 340 },
            { name: "Aegis", filename: "6700_aegis.png", id: 341 },
            { name: "Icon", filename: "6701_icon.png", id: 342 },
            { name: "Opportunity", filename: "6701_opportunity.png", id: 343 },
            { name: "Oracle Lens (Brawl)", filename: "6702_class_t1_oracleslens.brawl.png", id: 344 },
            { name: "Ornn Claws", filename: "7000_ornn_claws.png", id: 345 },
            { name: "Ornn Glory", filename: "7003_ornn_glory.png", id: 346 },
            { name: "Mirage Blade", filename: "7100_mirageblade.png", id: 347 },
            { name: "Gambler's Blade", filename: "7101_gamblers_blade.png", id: 348 },
            { name: "Reality Fracture", filename: "7102_realityfracture.png", id: 349 },
            { name: "Hemomancer's Helm", filename: "7103_hemomancershelm.png", id: 350 },
            { name: "Angelic Promise", filename: "7105_angelicpromise.png", id: 351 },
            { name: "Dragonheart", filename: "7106_dragonheart.png", id: 352 },
            { name: "Decapitator", filename: "7107_decapitator.png", id: 353 },
            { name: "Runecarver", filename: "7108_runecarver.png", id: 354 },
            { name: "Moonflair Spellblade", filename: "7110_moonflairspellblade.png", id: 355 },
            { name: "Overlord's Bloodmail", filename: "7111_overlordsbloodmail.png", id: 356 },
            { name: "Flesh Eater", filename: "7112_flesheater.png", id: 357 },
            { name: "Detonation Orb", filename: "7113_detonationorb.png", id: 358 },
            { name: "Anathema's Chains", filename: "8001_tank_t3_anathemaschains.png", id: 359 },
            { name: "Abyssal Mask", filename: "8020_tank_t3_abyssalmask.png", id: 360 },
            { name: "Scatter Arrows", filename: "9190_scatterarrows.strawberryrebuild.png", id: 361 },
            { name: "Berserker's Greaves T3", filename: "boots_tier3_berserkersgreaves_64.png", id: 362 },
            { name: "Ionian Boots T3", filename: "boots_tier3_ionianboots_64.png", id: 363 },
            { name: "Mercury's Treads T3", filename: "boots_tier3_mercury_64.png", id: 364 },
            { name: "Plated Steelcaps T3", filename: "boots_tier3_platedsteelcaps_64.png", id: 365 },
            { name: "Sorcerer's Shoes T3", filename: "boots_tier3_sorceror_64.png", id: 366 },
            { name: "Boots of Swiftness T3", filename: "boots_tier3_swiftness_64.png", id: 367 },
            { name: "Synchronized Souls T3", filename: "boots_tier3_syncronisedsouls_64.png", id: 368 },
            { name: "Elixir of Avarice", filename: "elixir_of_avarice.png", id: 369 },
            { name: "Elixir of Force", filename: "elixir_of_force.png", id: 370 },
            { name: "Fiddlesticks Trinket", filename: "fiddlestickstrinket1.png", id: 371 },
            { name: "GP UI Placeholder", filename: "gp_ui_placeholder.png", id: 372 },
            { name: "Soul Juice AP/AD", filename: "icon_item_souljuice_abilitypowerattackdamage.png", id: 373 },
            { name: "Soul Juice Fun Hat", filename: "icon_item_souljuice_funhat.png", id: 374 },
            { name: "Icon Stat AR", filename: "icon_stat_ar.png", id: 375 },
            { name: "Soul Juice Green", filename: "icons_souljuice_green.png", id: 376 },
            { name: "Soul Juice Yellow", filename: "icons_souljuice_yellow.png", id: 377 },
            { name: "Shop Reroll", filename: "item_consumable_shopreroll.png", id: 378 },
            { name: "Orbital Laser", filename: "orbital_laser.png", id: 379 },
            { name: "Pyke Gold", filename: "pykegold.png", id: 380 },
            { name: "Radiant Virtue", filename: "radiantvirtue.png", id: 381 },
            { name: "Stealth Ward Item", filename: "stealth_ward_29_item.png", id: 382 },
            { name: "Teleport Home", filename: "teleporthome.png", id: 383 },
            { name: "Teleport Home Disabled", filename: "teleporthomedisabled.png", id: 384 }
        ];

        const arenaItemsDataArray = [
            { name: "Shurelya's Battlesong", filename: "2065_shurelyasbattlesong.png", id: 1 },
            { name: "Unending Despair", filename: "2502_unendingdespair.png", id: 2 },
            { name: "Blackfire Torch", filename: "2503_blackfiretorch.png", id: 3 },
            { name: "Kaenic Rookern", filename: "2504_kaenicrookern.png", id: 4 },
            { name: "Archangel's Staff", filename: "3003_archangelsstaff.png", id: 5 },
            { name: "Manamune", filename: "3004_manamune.png", id: 6 },
            { name: "Atma's Reckoning", filename: "3005_atmasreckoning.png", id: 7 },
            { name: "Chemtech Putrifier", filename: "3011_chemtechputrifier.png", id: 8 },
            { name: "Guardian Angel", filename: "3026_guardianangel.png", id: 9 },
            { name: "Infinity Edge", filename: "3031_infinityedge.png", id: 10 },
            { name: "Innervating Locket", filename: "3032_innervatinglocket.png", id: 11 },
            { name: "Yun Tal Wildarrows", filename: "3032_yuntalwildarrows.png", id: 12 },
            { name: "Mortal Reminder", filename: "3033_mortalreminder.png", id: 13 },
            { name: "Lord Dominik's Regards", filename: "3036_lorddominiksregards.png", id: 14 },
            { name: "Phantom Dancer", filename: "3046_phantomdancer.png", id: 15 },
            { name: "Seraph's Embrace", filename: "3048_seraphsembrace.png", id: 16 },
            { name: "Zeke's Convergence", filename: "3050_zekesconvergence.png", id: 17 },
            { name: "Sterak's Gage", filename: "3053_steraksgage.png", id: 18 },
            { name: "Silversteel Talons", filename: "3054_silversteeltalons.png", id: 19 },
            { name: "Fulmination", filename: "3055_fulmination.png", id: 20 },
            { name: "Demon King's Crown", filename: "3056_demonkingscrown.png", id: 21 },
            { name: "Shield of Molten Stone", filename: "3058_shieldofmoltenstone.png", id: 22 },
            { name: "Cloak of Starry Night", filename: "3059_cloakofstarrynight.png", id: 23 },
            { name: "Force of Entropy", filename: "3061_forceofentropy.png", id: 24 },
            { name: "Sanguine Gift", filename: "3062_sanguinegift.png", id: 25 },
            { name: "Elisha's Miracle", filename: "3063_elishasmiracle.png", id: 26 },
            { name: "Talisman of Ascension", filename: "3064_talismanofascension.png", id: 27 },
            { name: "Spirit Visage", filename: "3065_spiritvisage.png", id: 28 },
            { name: "Sunfire Aegis", filename: "3068_sunfireaegis.png", id: 29 },
            { name: "Hamstringer", filename: "3069_hamstringer.png", id: 30 },
            { name: "Black Cleaver", filename: "3071_blackcleaver.png", id: 31 },
            { name: "Bloodthirster", filename: "3072_bloodthirster.png", id: 32 },
            { name: "Experimental Hexplate", filename: "3073_experimentalhexplate.png", id: 33 },
            { name: "Ravenous Hydra", filename: "3074_ravenoushydra.png", id: 34 },
            { name: "Thornmail", filename: "3075_thornmail.png", id: 35 },
            { name: "Trinity Force", filename: "3078_trinityforce.png", id: 36 },
            { name: "Warmog's Armor", filename: "3083_warmogs.png", id: 37 },
            { name: "Heartsteel", filename: "3084_heartsteel.png", id: 38 },
            { name: "Runaan's Hurricane", filename: "3085_runaans.png", id: 39 },
            { name: "Statikk Shiv", filename: "3087_statikkshiv.png", id: 40 },
            { name: "Rabadon's Deathcap", filename: "3089_deathcap.png", id: 41 },
            { name: "Wit's End", filename: "3091_witsend.png", id: 42 },
            { name: "Rapid Firecannon", filename: "3094_rapidfirecannon.png", id: 43 },
            { name: "Stormrazor", filename: "3095_stormrazor.png", id: 44 },
            { name: "Lich Bane", filename: "3100_lichbane.png", id: 45 },
            { name: "Banshee's Veil", filename: "3102_bansheesveil.png", id: 46 },
            { name: "Redemption", filename: "3107_redemption.png", id: 47 },
            { name: "Knight's Vow", filename: "3109_knightsvow.png", id: 48 },
            { name: "Frozen Heart", filename: "3110_frozenheart.png", id: 49 },
            { name: "Nashor's Tooth", filename: "3115_nashorstooth.png", id: 50 },
            { name: "Rylai's Crystal Scepter", filename: "3116_rylaiscrystalscepter.png", id: 51 },
            { name: "Malignance", filename: "3118_malignance.png", id: 52 },
            { name: "Winter's Approach", filename: "3119_wintersapproach.png", id: 53 },
            { name: "Guinsoo's Rageblade", filename: "3124_guinsoosrageblade.png", id: 54 },
            { name: "Sword of the Divine", filename: "3131_swordofthedivine.png", id: 55 },
            { name: "Void Staff", filename: "3135_voidstaff.png", id: 56 },
            { name: "Cryptbloom", filename: "3137_cryptbloom.png", id: 57 },
            { name: "Mercurial Scimitar", filename: "3139_mercurialscimitar.png", id: 58 },
            { name: "Youmuu's Ghostblade", filename: "3142_youmuusghostblade.png", id: 59 },
            { name: "Randuin's Omen", filename: "3143_randuinsomen.png", id: 60 },
            { name: "Hextech Gunblade", filename: "3146_hextechgunblade.png", id: 61 },
            { name: "Hextech Rocketbelt", filename: "3152_hextechrocketbelt.png", id: 62 },
            { name: "Blade of the Ruined King", filename: "3153_bladeoftheruinedking.png", id: 63 },
            { name: "Maw of Malmortius", filename: "3156_mawofmalmortius.png", id: 64 },
            { name: "Zhonya's Hourglass", filename: "3157_zhonyashourglass.png", id: 65 },
            { name: "Spear of Shojin", filename: "3161_spearofshojin.png", id: 66 },
            { name: "Morellonomicon", filename: "3165_morellonomicon.png", id: 67 },
            { name: "Zephyr", filename: "3172_zephyr.png", id: 68 },
            { name: "Hullbreaker", filename: "3181_hullbreaker.png", id: 69 },
            { name: "Locket of the Iron Solari", filename: "3190_locketoftheironsolari.png", id: 70 },
            { name: "Gargoyle Stoneplate", filename: "3193_gargoylestoneplate.png", id: 71 },
            { name: "Mikael's Blessing", filename: "3222_mikaelsblessing.png", id: 72 },
            { name: "Terminus", filename: "3302_terminus.png", id: 73 },
            { name: "Rite of Ruin", filename: "3430_riteofruin.png", id: 74 },
            { name: "Ardent Censer", filename: "3504_ardentcenser.png", id: 75 },
            { name: "Essence Reaver", filename: "3508_essencereaver.png", id: 76 },
            { name: "Dead Man's Plate", filename: "3742_deadmansplate.png", id: 77 },
            { name: "Titanic Hydra", filename: "3748_titanichydra.png", id: 78 },
            { name: "Edge of Night", filename: "3814_edgeofnight.png", id: 79 },
            { name: "Spectral Cutlass", filename: "4004_spectralcutlass.png", id: 80 },
            { name: "Imperial Mandate", filename: "4005_imperialmandate.png", id: 81 },
            { name: "Bloodletter's Veil", filename: "4010_bloodlettersveil.png", id: 82 },
            { name: "Sword of Blossoming Dawn", filename: "4011_swordofblossomingdawn.png", id: 83 },
            { name: "Perplexity", filename: "4015_perplexity.png", id: 84 },
            { name: "Wordless Promise", filename: "4016_wordlesspromise.png", id: 85 },
            { name: "Hellfire Hatchet", filename: "4017_hellfirehatchet.png", id: 86 },
            { name: "Force of Nature", filename: "4401_forceofnature.png", id: 87 },
            { name: "Twin Masks", filename: "443080_twinmasks.png", id: 88 },
            { name: "Hexbolt Companion", filename: "443081_hexboltcompanion.png", id: 89 },
            { name: "Reaper's Toll", filename: "443090_reaperstoll.png", id: 90 },
            { name: "Reverberation", filename: "447114_reverberation.png", id: 91 },
            { name: "Regicide", filename: "447115_regicide.png", id: 92 },
            { name: "Kinkou Jitte", filename: "447116_kinkoujitte.png", id: 93 },
            { name: "Pyromancer's Cloak", filename: "447118_pyromancerscloak.png", id: 94 },
            { name: "Lightning Rod", filename: "447119_lightningrod.png", id: 95 },
            { name: "Diamond-Tipped Spear", filename: "447120_diamondtippedspear.png", id: 96 },
            { name: "Twilight's Edge", filename: "447121_twilightsedge.png", id: 97 },
            { name: "Black Hole Gauntlet", filename: "447122_blackholegauntlet.png", id: 98 },
            { name: "Puppeteer", filename: "447123_puppeteer.png", id: 99 },
            { name: "Horizon Focus", filename: "4628_horizonfocus.png", id: 100 },
            { name: "Cosmic Drive", filename: "4629_cosmicdrive.png", id: 101 },
            { name: "Riftmaker", filename: "4633_riftmaker.png", id: 102 },
            { name: "Night Harvester", filename: "4636_nightharvester.png", id: 103 },
            { name: "Demonic Embrace", filename: "4637_demonicembrace.png", id: 104 },
            { name: "Crown of the Shattered Queen", filename: "4644_crownoftheshatteredqueen.png", id: 105 },
            { name: "Shadowflame", filename: "4645_shadowflame.png", id: 106 },
            { name: "Stormsurge", filename: "4646_stormsurge.png", id: 107 },
            { name: "Cruelty", filename: "6035_silvermeredawn.png", id: 108 },
            { name: "Death's Dance", filename: "6333_deathsdance.png", id: 109 },
            { name: "Chempunk Chainsword", filename: "6609_chempunkchainsword.png", id: 110 },
            { name: "Sundered Sky", filename: "6610_sunderedsky.png", id: 111 },
            { name: "Staff of Flowing Water", filename: "6616_staffofflowingwater.png", id: 112 },
            { name: "Moonstone Renewer", filename: "6617_moonstonerenewer.png", id: 113 },
            { name: "Echoes of Helia", filename: "6620_echoesofhelia.png", id: 114 },
            { name: "Dawncore", filename: "6621_dawncore.png", id: 115 },
            { name: "Goredrinker", filename: "6630_goredrinker.png", id: 116 },
            { name: "Stridebreaker", filename: "6631_stridebreaker.png", id: 117 },
            { name: "Divine Devourer", filename: "6632_divinedevourer.png", id: 118 },
            { name: "Liandry's Anguish", filename: "6653_liandrysanguish.png", id: 119 },
            { name: "Caster's Companion", filename: "6655_casterscompanion.png", id: 120 },
            { name: "Everfrost", filename: "6656_everfrost.png", id: 121 },
            { name: "Rod of Ages", filename: "6657_rodofages.png", id: 122 },
            { name: "Iceborn Gauntlet", filename: "6662_iceborngauntlet.png", id: 123 },
            { name: "Hollow Radiance", filename: "6664_hollowradiance.png", id: 124 },
            { name: "Turbo Chemtank", filename: "6664_turbochemtank.png", id: 125 },
            { name: "Jak'Sho, The Protean", filename: "6665_jakshotheprotean.png", id: 126 },
            { name: "Radiant Virtue", filename: "6667_radiantvirtue.png", id: 127 },
            { name: "Galeforce", filename: "6671_galeforce.png", id: 128 },
            { name: "Kraken Slayer", filename: "6672_krakenslayer.png", id: 129 },
            { name: "Immortal Shieldbow", filename: "6673_immortalshieldbow.png", id: 130 },
            { name: "Navori Quickblades", filename: "6675_navoriquickblades.png", id: 131 },
            { name: "The Collector", filename: "6676_thecollector.png", id: 132 },
            { name: "Duskblade of Draktharr", filename: "6691_duskblade.png", id: 133 },
            { name: "Eclipse", filename: "6692_eclipse.png", id: 134 },
            { name: "Prowler's Claw", filename: "6693_prowlersclaw.png", id: 135 },
            { name: "Serylda's Grudge", filename: "6694_seryldasgrudge.png", id: 136 },
            { name: "Serpent's Fang", filename: "6695_serpentsfang.png", id: 137 },
            { name: "Axiom Arc", filename: "6696_axiomarc.png", id: 138 },
            { name: "Hubris", filename: "6697_hubris.png", id: 139 },
            { name: "Profane Hydra", filename: "6698_profanehydra.png", id: 140 },
            { name: "Voltaic Cyclosword", filename: "6699_voltaiccyclosword.png", id: 141 },
            { name: "Opportunity", filename: "6701_opportunity.png", id: 142 },
            { name: "Mirage Blade", filename: "7100_mirageblade.png", id: 143 },
            { name: "Gambler's Blade", filename: "7101_gamblersblade.png", id: 144 },
            { name: "Reality Fracture", filename: "7102_realityfracture.png", id: 145 },
            { name: "Hemomancer's Helm", filename: "7103_hemomancershelm.png", id: 146 },
            { name: "Angelic Promise", filename: "7105_angelicpromise.png", id: 147 },
            { name: "Dragonheart", filename: "7106_dragonheart.png", id: 148 },
            { name: "Decapitator", filename: "7107_decapitator.png", id: 149 },
            { name: "Runecarver", filename: "7108_runecarver.png", id: 150 },
            { name: "Moonflair Spellblade", filename: "7110_moonflairspellblade.png", id: 151 },
            { name: "Overlord's Bloodmail", filename: "7111_overlordsbloodmail.png", id: 152 },
            { name: "Flesh Eater", filename: "7112_flesheater.png", id: 153 },
            { name: "Detonation Orb", filename: "7113_detonationorb.png", id: 154 },
            { name: "Anathema's Chains", filename: "8001_anathemaschains.png", id: 155 },
            { name: "Abyssal Mask", filename: "8020_abyssalmask.png", id: 156 }
        ];

        // Item modifiers data
        const itemModifiersDataArray = [
            { name: "None", filename: "", id: 0 },
            { name: "Blood Moon Modifier", filename: "bloodmoonmodifier.png", id: 1 },
            { name: "Border Treatment Mythic", filename: "bordertreatmentmythic.png", id: 2 },
            { name: "Border Treatment Ornn", filename: "bordertreatmentornn.png", id: 3 },
            { name: "Border Treatment Prismatic", filename: "bordertreatmentprismatic.png", id: 4 },
            { name: "Gold Corners Overlay", filename: "goldcornersoverlay.png", id: 5 },
            { name: "Noxus Item Border", filename: "noxus_item_border_.png", id: 6 },
            { name: "Strawberry Weapon Evolve Border", filename: "strawberry_weapon_evolve_border.png", id: 7 },
            { name: "Weirding Witch Hat", filename: "weirdingwitchat.png", id: 8 },
            { name: "Gold Item", filename: "gold_item_modifier.png", id: 9 },
            { name: "Prismatic Item", filename: "prismatic_item_modifier.png", id: 10 }
        ];

        const aram_mayhem_augments = [
            "adamant",
            "babykitty",
            "biggestsnowballever",
            "cheating",
            "criticalrhythm",
            "cruelty",
            "darksteeltalons",
            "empyreampromise",
            "escapeplan",
            "fetch",
            "finalform",
            "flash2",
            "getexcited",
            "glasscannon",
            "goldrend",
            "hatonahat",
            "kingme",
            "laseheal",
            "mightyshield",
            "mobiuscoil",
            "nightstalking",
            "poltergeist",
            "proteinshake",
            "quest_urfschampion",
            "sneakerhead",
            "snowballroulette",
            "snowballupgrade",
            "spiritualpurification",
            "swiftandsafe",
            "thebrutalizer",
            "upgradecollector",
            "upgradecutlass",
            "upgradehubris",
            "upgradeie",
            "upgradeimmolate",
            "upgrademikaelsblessing",
            "upgradesheen",
            "upgradezh",
            "vampired",
            "windbeneathblade",
            "zerohour"
        ];

        // Convert ARAM augment names to proper data structure
        let aramAugmentsData = null;

        function createAramAugmentsData() {
            aramAugmentsData = aram_mayhem_augments.map((augmentName, index) => {
                // Create display name by capitalizing and formatting
                const displayName = augmentName
                    .replace(/([a-z])([A-Z])/g, '$1 $2') // Add space before capital letters
                    .replace(/^./, str => str.toUpperCase()) // Capitalize first letter
                    .replace(/upgrade/gi, 'Upgrade ') // Add space after "upgrade"
                    .replace(/quest_/gi, 'Quest: ') // Replace quest_ with "Quest: "
                    .replace(/\s+/g, ' ') // Clean up multiple spaces
                    .trim();

                return {
                    id: index + 1,
                    name: displayName,
                    filename: augmentName,
                    element: null
                };
            }).sort(compareNames);
        }

        function createAramAugmentButton(augmentData) {
            const container = document.createElement("div");
            container.setAttribute("class", "augmentButton");
            container.setAttribute("onclick", "setSelectedAramAugment('" + augmentData['filename'] + "')");

            const augmentName = document.createElement("span");
            augmentName.innerText = augmentData['name'];
            container.appendChild(augmentName);

            const image = document.createElement("img");
            image.setAttribute("src", aramMayhemAugmentsBaseUrl + augmentData['filename'] + "_large.png");
            container.appendChild(image);

            return container;
        }

        function displayAramAugments() {
            if (!aramAugmentsData) {
                createAramAugmentsData();
            }
            
            aramAugmentsData.map((augmentData) => {
                augmentData['element'] = createAramAugmentButton(augmentData);
                return augmentData;
            });
        }

        function setSelectedAramAugment(filename) {
            // Clear other selections
            settings['selectedAugment'] = null;
            settings['selectedChampion'] = null;
            settings['selectedArenaItem'] = null;
            settings['selectedItem'] = null;
            settings['customImage'] = null;
            
            // Set the ARAM augment image URL
            settings['selectedAramAugment'] = filename;
            
            // Only set the image, don't change title or description
            mergeAugmentImages();
        }

        // ===== MAIN APPLICATION =====
        const settings = {
            selectedAugment: null,
            selectedFrame: "augmentcard_frame_prismatic.png",
            shinyFrame: false,
            augmentTitle: "",
            augmentDescription: "",
            iconXOffset: 156,
            iconYOffset: 40,
            iconSize: 150,
            titleFont: "bold 24px LolBeautfortBold",
            descriptionFont: "14px LolBeautfort",
            selectedChampion: null,
            selectedItem: null,
            selectedModifier: 0,
            titleYOffset: 324,
            descriptionYOffset: 364,
            titleLineHeight: 26,
            descriptionLineHeight: 18,
            language: 'en_us',
            customImage: null,
            customFrame: null
        };

        const borderImages = {
            augmentcard_bg: "augmentcard_bg.png",
            augmentcard_frame_silver: "augmentcard_frame_silver.png",
            augmentcard_frame_gold: "augmentcard_frame_gold.png",
            augmentcard_frame_prismatic: "augmentcard_frame_prismatic.png",
            augmentcard_sheenglow_silver: "augmentcard_sheenglow_silver.png",
            augmentcard_sheenglow_gold: "augmentcard_sheenglow_gold.png",
            augmentcard_sheenglow_prismatic: "augmentcard_sheenglow_prismatic.png",
        };

        const augmentFrameBaseUrl = communityDragonBaseUrl + "assets/ux/cherry/augments/augmentselection/";

        let augmentSearch = "";
        let arenaAugmentSearch = "";
        let aramAugmentSearch = "";
        let championSearch = "";
        let itemSearch = "";
        let arenaItemSearch = "";
        let currentIconTab = "champions";
        let currentAugmentTab = "arena";

        function updateAugmentSearch(value) {
            augmentSearch = value;
            filterAugments();
        }

        function updateArenaAugmentSearch(value) {
            arenaAugmentSearch = value;
            filterArenaAugments();
        }

        function updateAramAugmentSearch(value) {
            aramAugmentSearch = value;
            filterAramAugments();
        }

        function updateChampionSearch(value) {
            championSearch = value;
            filterChampions();
        }

        function updateItemSearch(value) {
            itemSearch = value;
            filterItems();
        }

        function updateArenaItemSearch(value) {
            arenaItemSearch = value;
            filterArenaItems();
        }

        function switchAugmentTab(tab) {
            currentAugmentTab = tab;
            
            // Update tab button states
            const arenaAugmentsTabBtns = document.querySelectorAll('[id^="arenaAugmentsTabBtn"]');
            const aramAugmentsTabBtns = document.querySelectorAll('[id^="aramAugmentsTabBtn"]');
            
            arenaAugmentsTabBtns.forEach(btn => {
                btn.classList.toggle('active', tab === 'arena');
            });
            aramAugmentsTabBtns.forEach(btn => {
                btn.classList.toggle('active', tab === 'aram');
            });
            
            // Show/hide appropriate content
            document.getElementById('arenaAugmentsContent').style.display = tab === 'arena' ? 'block' : 'none';
            document.getElementById('aramAugmentsContent').style.display = tab === 'aram' ? 'block' : 'none';
            
            // Clear search when switching tabs
            if (tab === 'arena') {
                document.getElementById('arenaAugmentSearchInput').value = '';
                updateArenaAugmentSearch('');
            } else {
                document.getElementById('aramAugmentSearchInput').value = '';
                updateAramAugmentSearch('');
            }
        }

        function switchIconTab(tab) {
            currentIconTab = tab;
            
            // Update tab button states
            const championsTabBtns = document.querySelectorAll('#championsTabBtn');
            const arenaItemsTabBtns = document.querySelectorAll('#arenaItemsTabBtn');
            const itemsTabBtns = document.querySelectorAll('#itemsTabBtn');
            
            championsTabBtns.forEach(btn => {
                btn.classList.toggle('active', tab === 'champions');
            });
            arenaItemsTabBtns.forEach(btn => {
                btn.classList.toggle('active', tab === 'arenaItems');
            });
            itemsTabBtns.forEach(btn => {
                btn.classList.toggle('active', tab === 'items');
            });
            
            // Show/hide appropriate content
            document.getElementById('championsContent').style.display = tab === 'champions' ? 'block' : 'none';
            document.getElementById('arenaItemsContent').style.display = tab === 'arenaItems' ? 'block' : 'none';
            document.getElementById('itemsContent').style.display = tab === 'items' ? 'block' : 'none';
            
            // Clear search when switching tabs
            if (tab === 'champions') {
                document.getElementById('championSearchInput').value = '';
                updateChampionSearch('');
            } else if (tab === 'arenaItems') {
                document.getElementById('arenaItemSearchInput').value = '';
                updateArenaItemSearch('');
            } else {
                document.getElementById('itemSearchInput').value = '';
                updateItemSearch('');
            }
        }

        function setDefaultTitleFont() {
            settings['titleFont'] = "bold 24px LolBeautfortBold";
            document.getElementById("titleFontInput").value = "bold 24px LolBeautfortBold";
        }

        function setDefaultDescriptionFont() {
            settings['descriptionFont'] = "14px LolBeautfort";
            document.getElementById("descriptionFontInput").value = "14px LolBeautfort";
        }

        function createAugmentButton(augmentData) {
            const container = document.createElement("div");
            container.setAttribute("class", "augmentButton");
            container.setAttribute("onclick", "setSelectedAugment(" + augmentData['id'] + ")");

            const augmentName = document.createElement("span");
            augmentName.innerText = augmentData['name'];
            container.appendChild(augmentName);

            const image = document.createElement("img");
            image.setAttribute("src", communityDragonBaseUrl + augmentData['iconLarge'])
            container.appendChild(image);

            return container;
        }

        function displayAugments(data) {
            data.map((augmentData) => {
                augmentData['element'] = createAugmentButton(augmentData);
                return augmentData;
            });
        }

        function createChampionButton(champion) {
            const container = document.createElement("div");
            container.setAttribute("class", "augmentButton");
            container.setAttribute("onclick", "setSelectedChampion(" + champion['id'] + ")");

            const championName = document.createElement("span");
            championName.innerText = champion['name'];
            container.appendChild(championName);

            const image = document.createElement("img");
            image.setAttribute("src", baseSquarePortraitPath + champion['id'] + ".png")
            container.appendChild(image);

            return container;
        }

        function displayChampions(data) {
            data.map((champion) => {
                champion['element'] = createChampionButton(champion);
                return champion;
            });
        }

        function filterAugments() {
            const augmentsList = document.getElementById("augmentsList");
            augmentsList.innerHTML = "";
            if (arenaJsonData) {
                arenaJsonData.filter((e) => (e['name'].toLowerCase().includes(augmentSearch.toLowerCase()) > 0))
                    .forEach((e) => augmentsList.appendChild(e.element));
            }
        }

        function filterArenaAugments() {
            const arenaAugmentsList = document.getElementById("arenaAugmentsList");
            arenaAugmentsList.innerHTML = "";
            if (arenaJsonData) {
                arenaJsonData.filter((e) => (e['name'].toLowerCase().includes(arenaAugmentSearch.toLowerCase()) > 0))
                    .forEach((e) => arenaAugmentsList.appendChild(e.element));
            }
        }

        function filterAramAugments() {
            const aramAugmentsList = document.getElementById("aramAugmentsList");
            aramAugmentsList.innerHTML = "";
            if (aramAugmentsData) {
                aramAugmentsData.filter((e) => (e['name'].toLowerCase().includes(aramAugmentSearch.toLowerCase()) > 0))
                    .forEach((e) => aramAugmentsList.appendChild(e.element));
            }
        }

        function filterChampions() {
            const championsList = document.getElementById("championsList");
            championsList.innerHTML = "";
            if (championJsonData) {
                championJsonData.filter((e) => (e['name'].toLowerCase().includes(championSearch.toLowerCase()) > 0))
                    .forEach((e) => championsList.appendChild(e.element));
            }
        }

        function setSelectedAugment(id) {
            settings['selectedAugment'] = arenaJsonData.filter((e) => e['id'] === id)[0];
            settings['selectedChampion'] = null;
            settings['customImage'] = null;

            const rarity = settings['selectedAugment']['rarity'];
            switch (rarity) {
                case 0:
                    settings['selectedFrame'] = borderImages['augmentcard_frame_silver'];
                    break;
                case 1:
                    settings['selectedFrame'] = borderImages['augmentcard_frame_gold'];
                    break;
                case 2:
                    settings['selectedFrame'] = borderImages['augmentcard_frame_prismatic'];
                    break;
                default:
                    settings['selectedFrame'] = borderImages['augmentcard_bg'];
            }
            settings['shinyFrame'] = false;

            settings['augmentTitle'] = settings['selectedAugment']['name'];
            document.getElementById('titleInput').value = settings['augmentTitle'];
            settings['augmentDescription'] = populateDescriptionVariables(settings['selectedAugment']);
            document.getElementById('descriptionInput').value = settings['augmentDescription'];

            mergeAugmentImages();
        }

        function setSelectedChampion(id) {
            settings['selectedChampion'] = championJsonData.filter((e) => e['id'] === id)[0];
            settings['selectedAugment'] = null;
            settings['selectedItem'] = null;
            settings['customImage'] = null;
            mergeAugmentImages();
        }

        function createItemButton(item) {
            const container = document.createElement("div");
            container.setAttribute("class", "augmentButton");
            container.setAttribute("onclick", "setSelectedItem(" + item['id'] + ")");

            const itemName = document.createElement("span");
            itemName.innerText = item['name'];
            container.appendChild(itemName);

            const image = document.createElement("img");
            image.setAttribute("src", itemIconsBaseUrl + item['filename']);
            container.appendChild(image);

            return container;
        }

        function displayItems(data) {
            data.map((item) => {
                item['element'] = createItemButton(item);
                return item;
            });
        }

        function filterItems() {
            const itemsList = document.getElementById("itemsList");
            itemsList.innerHTML = "";
            const itemsData = itemsDataArray.sort(compareNames);
            if (itemsData) {
                itemsData.filter((e) => (e['name'].toLowerCase().includes(itemSearch.toLowerCase()) > 0))
                    .forEach((e) => itemsList.appendChild(e.element));
            }
        }

        function setSelectedItem(id) {
            settings['selectedItem'] = itemsDataArray.filter((e) => e['id'] === id)[0];
            settings['selectedAugment'] = null;
            settings['selectedChampion'] = null;
            settings['selectedArenaItem'] = null;
            settings['customImage'] = null;
            settings['augmentTitle'] = settings['selectedItem'].name;
            document.getElementById('titleInput').value = settings['augmentTitle'];

            mergeAugmentImages();
        }

        function createArenaItemButton(item) {
            const container = document.createElement("div");
            container.setAttribute("class", "augmentButton");
            container.setAttribute("onclick", "setSelectedArenaItem(" + item['id'] + ")");

            const itemName = document.createElement("span");
            itemName.innerText = item['name'];
            container.appendChild(itemName);

            const image = document.createElement("img");
            image.setAttribute("src", arenaItemIconsBaseUrl + item['filename']);
            container.appendChild(image);

            return container;
        }

        function displayArenaItems(data) {
            data.map((item) => {
                item['element'] = createArenaItemButton(item);
                return item;
            });
        }

        function filterArenaItems() {
            const arenaItemsList = document.getElementById("arenaItemsList");
            arenaItemsList.innerHTML = "";
            const arenaItemsData = arenaItemsDataArray.sort(compareNames);
            if (arenaItemsData) {
                arenaItemsData.filter((e) => (e['name'].toLowerCase().includes(arenaItemSearch.toLowerCase()) > 0))
                    .forEach((e) => arenaItemsList.appendChild(e.element));
            }
        }

        function setSelectedArenaItem(id) {
            settings['selectedArenaItem'] = arenaItemsDataArray.filter((e) => e['id'] === id)[0];
            settings['selectedAugment'] = null;
            settings['selectedChampion'] = null;
            settings['selectedItem'] = null;
            settings['customImage'] = null;
            
            // Set the title
            settings['augmentTitle'] = settings['selectedArenaItem'].name;
            document.getElementById('titleInput').value = settings['augmentTitle'];
            
            // Set the description using fetched data
            let description = '';
            if (settings['selectedArenaItem'].description) {
                description = settings['selectedArenaItem'].description;
                
                // Add brief (flavor text) if available, separated by a line break
                // if (settings['selectedArenaItem'].brief) {
                //     description += '\n\n' + settings['selectedArenaItem'].brief;
                // }
            } else if (settings['selectedArenaItem'].brief) {
                // Use brief as fallback if no main description
                // description = settings['selectedArenaItem'].brief;
            }
            
            // Process the description to convert %i:keyword% patterns to <imgkeyword> tags
            // Create a temporary object that mimics an augment for the conversion function
            const tempItem = { desc: description, dataValues: {} };
            const processedDescription = populateDescriptionVariables(tempItem);
            
            settings['augmentDescription'] = processedDescription;
            document.getElementById('descriptionInput').value = settings['augmentDescription'];
            
            // Apply preferred frame based on item code type
            if (settings['selectedArenaItem'].preferredFrame) {
                settings['selectedFrame'] = borderImages[settings['selectedArenaItem'].preferredFrame];
                settings['shinyFrame'] = false; // Use regular frames, not shiny ones
            }
            
            mergeAugmentImages();
        }

        function updateModifierVariable(value) {
            settings['selectedModifier'] = parseInt(value);
            mergeAugmentImages();
        }

        function populateModifierDropdown() {
            const modifierSelect = document.getElementById('itemModifierSelect');
            
            modifierSelect.innerHTML = '';
            itemModifiersDataArray.forEach(modifier => {
                const option = document.createElement('option');
                option.value = modifier.id;
                option.textContent = modifier.name;
                modifierSelect.appendChild(option);
            });
        }

        function mergeAugmentImages() {
            let iconImage;

            if (settings['customImage']) {
                iconImage = settings['customImage'];
            } else if (settings['selectedAugment'] !== null) {
                iconImage = communityDragonBaseUrl + settings['selectedAugment']['iconLarge'];
            } else if (settings['selectedChampion'] !== null) {
                iconImage = baseSquarePortraitPath + settings['selectedChampion']['id'] + ".png";
            } else if (settings['selectedArenaItem'] !== null) {
                iconImage = arenaItemIconsBaseUrl + settings['selectedArenaItem']['filename'];
            } else if (settings['selectedItem'] !== null) {
                iconImage = itemIconsBaseUrl + settings['selectedItem']['filename'];
            } else if (settings['selectedAramAugment'] !== null) {
                iconImage = aramMayhemAugmentsBaseUrl + settings['selectedAramAugment'] + "_large.png";
            } else {
                return;
            }

            // Calculate centered positioning based on icon size
            // Default size is 150px, so we adjust the offset based on the difference
            const defaultSize = 150;
            const currentSize = parseInt(settings['iconSize']);
            const sizeDifference = (currentSize - defaultSize) / 2;
            
            const modifiedXOffset = parseInt(settings['iconXOffset']) + 25 - sizeDifference;
            const modifiedYOffset = parseInt(settings['iconYOffset']) + 10 - sizeDifference;
            const imagePositionOffsets = {2:[modifiedXOffset, modifiedYOffset]};

            // Determine frame image to use (custom or preset)
            let frameImage;
            if (settings['customFrame']) {
                frameImage = settings['customFrame'];
            } else {
                frameImage = augmentFrameBaseUrl + settings['selectedFrame'];
            }

            const images = [
                augmentFrameBaseUrl + borderImages['augmentcard_bg'],
                frameImage,
                iconImage
            ];

            // Add modifier overlay if selected
            if (settings['selectedModifier'] && settings['selectedModifier'] !== 0) {
                const modifier = itemModifiersDataArray.find(m => m.id === settings['selectedModifier']);

                if (modifier.id === 9) { // or whatever your gold modifier ID is
                    images.push('images/gold_item_modifier.png');
                } else if (modifier.id === 10) { // or whatever your prismatic modifier ID is
                    images.push('images/prismatic_item_modifier.png');
                } else if (modifier && modifier.filename) {
                    const modifierUrl = itemModifiersBaseUrl + modifier.filename;
                    images.push(modifierUrl);
                }
                imagePositionOffsets[3] = [modifiedXOffset, modifiedYOffset]; // Same position as icon
            }

            mergeImages(images, {}, imagePositionOffsets, settings['augmentTitle'], settings['augmentDescription'], settings['iconSize'])
                .then(b64 => document.getElementById('imageOutput').src = b64);
        }

        function updateCanvasVariable(value, variable) {
            settings[variable] = value;
            mergeAugmentImages();
        }

        function updateFrameVariable(value) {
            settings['selectedFrame'] = borderImages[value];
            settings['shinyFrame'] = value.includes("sheenglow");
            settings['customFrame'] = null; // Clear custom frame when preset is selected
            mergeAugmentImages();
        }

        function clearCustomFrame() {
            settings['customFrame'] = null;
            mergeAugmentImages();
        }

        async function setLanguage(value) {
            settings['language'] = value;
            await getAugmentData(value);
            if (settings['selectedAugment']) {
                setSelectedAugment(settings['selectedAugment']['id']);
            }

            const augmentsList = document.getElementById("augmentsList");
            augmentsList.innerHTML = "";
            displayAugments(arenaJsonData);
            filterAugments();

            mergeAugmentImages();
        }

        async function getArenaJson() {
            await getAugmentData();
            // Don't set default fonts here - they'll be loaded from localStorage in init()
            setSelectedAugment(1);
            displayAugments(arenaJsonData);
            filterArenaAugments(); // Use the new arena-specific filter
        }

        async function getChampionJson() {
            await getChampionData();
            displayChampions(championJsonData);
            filterChampions();
        }

        // Extract numeric code from item filename
        function extractItemCode(filename) {
            // Match patterns like "096_", "1001_", "7106_", etc.
            const match = filename.match(/^(\d+)_/);
            if (!match) return null;
            
            const code = match[1];
            // If code already starts with "44", use it as-is for stringtable lookup
            // Otherwise, we'll prepend "44" when constructing the key
            return code;
        }

        // Fetch arena item descriptions from stringtable and enhance arena items data
        async function fetchArenaItemDescriptions() {
            const stringtableUrl = "https://raw.communitydragon.org/pbe/game/en_us/data/menu/en_us/lol.stringtable.json";
            
            try {
                console.log("Fetching arena item descriptions from stringtable...");
                const response = await fetch(stringtableUrl);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                const entries = data.entries || {};
                
                // Step 1: Build name-to-codes mapping from stringtable
                console.log("Building name-to-codes mapping...");
                const nameToCodesMap = {};
                
                // Extract all item_ANYNUMBER_name entries
                Object.keys(entries).forEach(key => {
                    const nameMatch = key.match(/^item_(\d+)_name$/);
                    if (nameMatch) {
                        const code = nameMatch[1];
                        const itemName = entries[key];
                        
                        if (!nameToCodesMap[itemName]) {
                            nameToCodesMap[itemName] = [];
                        }
                        nameToCodesMap[itemName].push(code);
                    }
                });
                
                console.log(entries["generatedtip_item_447109_externaldescription"]);

                console.log(`Found ${Object.keys(nameToCodesMap).length} unique item names in stringtable`);
                
                // Step 2: Process each arena item with smart code selection
                let foundDescriptions = 0;
                let foundBriefs = 0;
                let foundNames = 0;
                let notFoundItems = [];
                
                arenaItemsDataArray.forEach(item => {
                    // Extract original code from filename for fallback
                    const originalCode = extractItemCode(item.filename);
                    item.originalCode = originalCode;
                    
                    // Try to find the item by name in stringtable
                    const possibleCodes = nameToCodesMap[item.name] || [];
                    
                    let selectedCode = null;
                    let selectedCodeType = 'none';
                    
                    if (possibleCodes.length > 0) {
                        // Step 3: Smart code selection with priority
                        // Priority 1: 22xxxx codes (arena versions of standard items)
                        const arena22Codes = possibleCodes.filter(code => code.startsWith('22'));
                        // Priority 2: 44xxxx codes (arena exclusives)
                        const arena44Codes = possibleCodes.filter(code => code.startsWith('44'));
                        // Priority 3: Other codes (standard versions)
                        const otherCodes = possibleCodes.filter(code => !code.startsWith('22') && !code.startsWith('44'));
                        
                        // Select best code with preference for those that have summaries
                        const selectBestCode = (codes, type) => {
                            if (codes.length === 0) return null;
                            
                            // Prefer codes that have summaries
                            const codesWithSummary = codes.filter(code => entries[`item_${code}_summary`]);
                            if (codesWithSummary.length > 0) {
                                selectedCodeType = type + '-with-summary';
                                return codesWithSummary[0];
                            }
                            
                            selectedCodeType = type;
                            return codes[0];
                        };
                        
                        // Try priorities in order
                        selectedCode = selectBestCode(arena22Codes, '22xxx') || 
                                     selectBestCode(arena44Codes, '44xxx') || 
                                     selectBestCode(otherCodes, 'other');
                    }
                    
                    // Fallback: try original code from filename if no name match found
                    if (!selectedCode && originalCode) {
                        // Try 22xxxx version first, then 44xxxx, then original
                        const fallbackCodes = [`22${originalCode}`, `44${originalCode}`, originalCode];
                        for (const code of fallbackCodes) {
                            if (entries[`item_${code}_name`]) {
                                selectedCode = code;
                                selectedCodeType = 'fallback-' + (code.startsWith('22') ? '22xxx' : code.startsWith('44') ? '44xxx' : 'original');
                                break;
                            }
                        }
                    }
                    
                    // Step 4: Populate item data if we found a valid code
                    if (selectedCode) {
                        item.code = selectedCode;
                        item.selectedCodeType = selectedCodeType;
                        
                        // Set preferred frame based on code type
                        if (selectedCode.startsWith('22')) {
                            item.preferredFrame = 'augmentcard_frame_gold';
                        } else if (selectedCode.startsWith('44')) {
                            item.preferredFrame = 'augmentcard_frame_prismatic';
                        } else {
                            item.preferredFrame = 'augmentcard_frame_gold'; // Default for other codes
                        }
                        
                        // Always use name from stringtable
                        const nameKey = `item_${selectedCode}_name`;
                        if (entries[nameKey]) {
                            item.name = entries[nameKey];
                            foundNames++;
                        }
                        
                        // Look for external description (includes stats with icons)
                        const externalDescKey = `generatedtip_item_${selectedCode}_externaldescription`;
                        const summaryKey = `item_${selectedCode}_summary`;
                        
                        let finalDescription = '';
                        
                        if (entries[externalDescKey]) {
                            // Extract the <stats> block from external description
                            const externalDesc = entries[externalDescKey];
                            const statsMatch = externalDesc.match(/<stats>(.*?)<\/stats>/s);
                            
                            if (statsMatch) {
                                // Clean up the stats block by removing newlines and <br> tags
                                let statsBlock = statsMatch[1];
                                statsBlock = statsBlock.replace(/<br\s*\/?>/gi, ' '); // Replace <br> with space
                                statsBlock = statsBlock.replace(/\n/g, ' '); // Replace newlines with space
                                statsBlock = statsBlock.replace(/\s+/g, ' '); // Collapse multiple spaces
                                statsBlock = statsBlock.trim(); // Remove leading/trailing whitespace
                                
                                // Get the summary text
                                const summaryText = entries[summaryKey] || '';
                                
                                // Combine: stats block + two newlines + summary
                                if (summaryText) {
                                    finalDescription = statsBlock + '\n\n' + summaryText;
                                } else {
                                    finalDescription = statsBlock;
                                }
                            } else {
                                // If no stats block found, use the full external description
                                finalDescription = externalDesc;
                            }
                            
                            item.description = finalDescription;
                            foundDescriptions++;
                        } else {
                            // Fallback to summary if external description not available
                            if (entries[summaryKey]) {
                                item.description = entries[summaryKey];
                                foundDescriptions++;
                            }
                        }
                        
                        // Look for brief (flavor text)
                        const briefKey = `item_${selectedCode}_brief`;
                        if (entries[briefKey]) {
                            item.brief = entries[briefKey];
                            foundBriefs++;
                        }
                        
                    } else {
                        // Item not found in stringtable
                        notFoundItems.push(item.name);
                        item.code = originalCode; // Keep original for debugging
                        item.selectedCodeType = 'not-found';
                        item.preferredFrame = 'augmentcard_frame_gold'; // Default frame
                    }
                });
                
                // Step 5: Report results
                console.log(`Arena item descriptions loaded: ${foundNames} names, ${foundDescriptions} descriptions, ${foundBriefs} briefs found out of ${arenaItemsDataArray.length} arena items`);
                
                if (notFoundItems.length > 0) {
                    console.warn(`Items not found in stringtable (${notFoundItems.length}):`, notFoundItems);
                }
                
                return {
                    totalItems: arenaItemsDataArray.length,
                    itemsWithCodes: arenaItemsDataArray.filter(item => item.code).length,
                    namesFound: foundNames,
                    descriptionsFound: foundDescriptions,
                    briefsFound: foundBriefs,
                    notFoundItems: notFoundItems
                };
                
            } catch (error) {
                console.error("Error fetching arena item descriptions:", error);
                
                // Still add original codes even if fetch fails
                arenaItemsDataArray.forEach(item => {
                    const code = extractItemCode(item.filename);
                    item.originalCode = code;
                    item.code = code;
                    item.selectedCodeType = 'error-fallback';
                });
                
                return {
                    error: error.message,
                    totalItems: arenaItemsDataArray.length,
                    itemsWithCodes: arenaItemsDataArray.filter(item => item.code).length,
                    namesFound: 0,
                    descriptionsFound: 0,
                    briefsFound: 0,
                    notFoundItems: []
                };
            }
        }

        async function init() {
            console.log("Starting index html")
            initializeDragDrop();
            
            // Initialize color table
            loadColorTable();
            
            // Initialize preset system
            populatePresetDropdown();
            
            // Initialize items and modifiers
            displayItems(itemsDataArray);
            filterItems();
            displayArenaItems(arenaItemsDataArray);
            filterArenaItems();
            populateModifierDropdown();
            
            // Initialize ARAM augments
            displayAramAugments();
            filterAramAugments();
            
            // Preload stat icons for inline images
            preloadStatIcons();
            
            // Load current preset instead of individual settings
            const currentPresetName = presetManager.getCurrentPresetName();
            presetManager.applyPreset(currentPresetName, settings);
            
            let p1 = getArenaJson();
            let p2 = getChampionJson();
            
            // Fetch arena item descriptions
            let p3 = fetchArenaItemDescriptions();

            Promise.all([p1, p2, p3]).then(() => {
                console.log("All data loaded successfully");
                // Apply saved language setting after data is loaded
                const savedLanguage = loadFromLocalStorage('language', 'en_us');
                if (savedLanguage !== 'en_us') {
                    setLanguage(savedLanguage);
                } else {
                    mergeAugmentImages();
                }
            });
        }

        init();
    </script>
</body>
</html>
